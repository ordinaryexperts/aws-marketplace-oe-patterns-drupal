import json
import os
import subprocess
import yaml
from aws_cdk import (
    aws_autoscaling,
    aws_cloudformation,
    aws_cloudfront,
    aws_cloudwatch,
    aws_codebuild,
    aws_codedeploy,
    aws_codepipeline,
    aws_codepipeline_actions,
    aws_ec2,
    aws_efs,
    aws_elasticache,
    aws_elasticloadbalancingv2,
    aws_iam,
    aws_lambda,
    aws_logs,
    aws_rds,
    aws_s3,
    aws_secretsmanager,
    aws_sns,
    aws_ssm,
    core
)

DEFAULT_DRUPAL_SOURCE_BUCKET="github-user-and-bucket-githubartifactbucket-wl52dae3lyub"
DEFAULT_DRUPAL_SOURCE_OBJECT_KEY="aws-marketplace-oe-patterns-drupal-example-site/refs/heads/develop.zip"
TWO_YEARS_IN_DAYS=731
try:
    template_version = subprocess.check_output(["git", "describe"]).strip().decode('ascii')
except:
    template_version = "CICD"

# When making a new development AMI:
# 1) $ ave oe-patterns-dev make ami-ec2-build
# 2) $ ave oe-patterns-dev make AMI_ID=ami-fromstep1 ami-ec2-copy
# 3) Copy the code that copy-image generates below

# AMI list generated by:
# make TEMPLATE_VERSION=1.0.0 ami-ec2-build
# on Mon Jun 22 22:04:23 UTC 2020.
AMI_ID="ami-05a7f3918c997345e"
AMI_NAME="ordinary-experts-patterns-drupal-1.0.0-20200622-0932"
generated_ami_ids = {
    "us-east-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "ca-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-north-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-3": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "sa-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-1": "ami-05a7f3918c997345e"
}
# End generated code block.

# Sanity check: if this fails then make copy-image needs to be run...
assert AMI_ID == generated_ami_ids["us-east-1"]

class DrupalStack(core.Stack):

    def __init__(self, scope: core.Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        current_directory = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        allowed_values = yaml.load(
            open(os.path.join(current_directory, "allowed_values.yaml")),
            Loader=yaml.SafeLoader
        )
        ami_mapping={
            "AMI": {
                "OEDRUPAL": AMI_NAME
            }
        }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "OEDRUPAL": generated_ami_ids[region] }
        aws_ami_region_map = core.CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        # utility function to parse the unique id from the stack id for
        # shorter resource names  using cloudformation functions
        def append_stack_uuid(name):
            return core.Fn.join("-", [
                name,
                core.Fn.select(0, core.Fn.split("-", core.Fn.select(2, core.Fn.split("/", core.Aws.STACK_ID))))
            ])

        pipeline_artifact_bucket_name_param = core.CfnParameter(
            self,
            "PipelineArtifactBucketName",
            default="",
            description="Optional: Specify a bucket name for the CodePipeline pipeline to use. The bucket must be in this same AWS account. This can be handy when re-creating this template many times."
        )
        pipeline_artifact_bucket_name_not_exists_condition = core.CfnCondition(
            self,
            "PipelineArtifactBucketNameNotExists",
            expression=core.Fn.condition_equals(pipeline_artifact_bucket_name_param.value, "")
        )
        pipeline_artifact_bucket_name_exists_condition = core.CfnCondition(
            self,
            "PipelineArtifactBucketNameExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(pipeline_artifact_bucket_name_param.value, ""))
        )
        pipeline_artifact_bucket = aws_s3.CfnBucket(
            self,
            "PipelineArtifactBucket",
            access_control="Private",
            bucket_encryption=aws_s3.CfnBucket.BucketEncryptionProperty(
                server_side_encryption_configuration=[
                    aws_s3.CfnBucket.ServerSideEncryptionRuleProperty(
                        server_side_encryption_by_default=aws_s3.CfnBucket.ServerSideEncryptionByDefaultProperty(
                            sse_algorithm="AES256"
                        )
                    )
                ]
            ),
            public_access_block_configuration=aws_s3.BlockPublicAccess.BLOCK_ALL
        )
        pipeline_artifact_bucket.cfn_options.condition=pipeline_artifact_bucket_name_not_exists_condition
        pipeline_artifact_bucket.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        pipeline_artifact_bucket.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        pipeline_artifact_bucket_arn = core.Arn.format(
            components=core.ArnComponents(
                account="",
                region="",
                resource=core.Token.as_string(
                    core.Fn.condition_if(
                        pipeline_artifact_bucket_name_exists_condition.logical_id,
                        pipeline_artifact_bucket_name_param.value_as_string,
                        pipeline_artifact_bucket.ref
                    )
                ),
                resource_name="*",
                service="s3"
            ),
            stack=self
        )
        source_artifact_bucket_name_param = core.CfnParameter(
            self,
            "SourceArtifactBucketName",
            default="",
            description="Optional: Specify a S3 Bucket name which will contain the build artifacts for the application. If not specified, a bucket will be created."
        )
        source_artifact_bucket_name_exists_condition = core.CfnCondition(
            self,
            "SourceArtifactBucketNameExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(source_artifact_bucket_name_param.value, ""))
        )
        source_artifact_bucket_name_not_exists_condition = core.CfnCondition(
            self,
            "SourceArtifactBucketNameNotExists",
            expression=core.Fn.condition_equals(source_artifact_bucket_name_param.value, "")
        )
        source_artifact_bucket = aws_s3.CfnBucket(
            self,
            "SourceArtifactBucket",
            access_control="Private",
            bucket_encryption=aws_s3.CfnBucket.BucketEncryptionProperty(
                server_side_encryption_configuration=[
                    aws_s3.CfnBucket.ServerSideEncryptionRuleProperty(
                        server_side_encryption_by_default=aws_s3.CfnBucket.ServerSideEncryptionByDefaultProperty(
                            sse_algorithm="AES256"
                        )
                    )
                ]
            ),
            public_access_block_configuration=aws_s3.BlockPublicAccess.BLOCK_ALL,
            versioning_configuration=aws_s3.CfnBucket.VersioningConfigurationProperty(
                status="Enabled"
            )
        )
        source_artifact_bucket.cfn_options.condition = source_artifact_bucket_name_not_exists_condition
        source_artifact_bucket.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        source_artifact_bucket.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        source_artifact_bucket_name = core.Token.as_string(
            core.Fn.condition_if(
                source_artifact_bucket_name_exists_condition.logical_id,
                source_artifact_bucket_name_param.value_as_string,
                source_artifact_bucket.ref
            )
        )
        source_artifact_bucket_arn = core.Arn.format(
            components=core.ArnComponents(
                account="",
                region="",
                resource=source_artifact_bucket_name,
                service="s3"
            ),
            stack=self
        )
        source_artifact_object_key_param = core.CfnParameter(
            self,
            "SourceArtifactObjectKey",
            default="drupal.zip",
            description="Required: AWS S3 Object key (path) for the build artifact for the application.  Updates to this object will trigger a deployment."
        )
        source_artifact_object_key_arn = core.Arn.format(
            components=core.ArnComponents(
                account="",
                region="",
                resource=source_artifact_bucket_name,
                resource_name=source_artifact_object_key_param.value_as_string,
                service="s3"
            ),
            stack=self
        )

        notification_email_param = core.CfnParameter(
            self,
            "NotificationEmail",
            default="",
            description="Optional: Specify an email address to get emails about deploys and other system events."
        )
        certificate_arn_param = core.CfnParameter(
            self,
            "CertificateArn",
            default="",
            description="Optional: Specify the ARN of a ACM Certificate to configure HTTPS."
        )
        certificate_arn_exists_condition = core.CfnCondition(
            self,
            "CertificateArnExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(certificate_arn_param.value, ""))
        )
        certificate_arn_does_not_exist_condition = core.CfnCondition(
            self,
            "CertificateArnNotExists",
            expression=core.Fn.condition_equals(certificate_arn_param.value, "")
        )
        notification_email_exists_condition = core.CfnCondition(
            self,
            "NotificationEmailExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(notification_email_param.value, ""))
        )

        # vpc
        vpc_id_param = core.CfnParameter(
            self,
            "VpcId",
            default="",
            description="Optional: Specify the VPC ID.  If not specified, a VPC will be created."
        )
        vpc_private_subnet_id1_param = core.CfnParameter(
            self,
            "VpcPrivateSubnetId1",
            default="",
            description="Optional: Specify Subnet ID for first private subnet."
        )
        vpc_private_subnet_id2_param = core.CfnParameter(
            self,
            "VpcPrivateSubnetId2",
            default="",
            description="Optional: Specify Subnet ID for second private subnet."
        )
        vpc_public_subnet_id1_param = core.CfnParameter(
            self,
            "VpcPublicSubnetId1",
            default="",
            description="Optional: Specify Subnet ID for first public subnet."
        )
        vpc_public_subnet_id2_param = core.CfnParameter(
            self,
            "VpcPublicSubnetId2",
            default="",
            description="Optional: Specify Subnet ID for second public subnet."
        )
        vpc_given_condition = core.CfnCondition(
            self,
            "VpcGiven",
            expression=core.Fn.condition_not(core.Fn.condition_equals(vpc_id_param.value, ""))
        )
        vpc_not_given_condition = core.CfnCondition(
            self,
            "VpcNotGiven",
            expression=core.Fn.condition_equals(vpc_id_param.value, "")
        )
        vpc = aws_ec2.CfnVPC(
            self,
            "Vpc",
            cidr_block="10.0.0.0/16",
            enable_dns_hostnames=True,
            enable_dns_support=True,
            instance_tenancy="default",
            tags=[core.CfnTag(key="Name", value="{}/Vpc".format(core.Aws.STACK_NAME))]
        )
        vpc.cfn_options.condition=vpc_not_given_condition

        vpc_igw = aws_ec2.CfnInternetGateway(
            self,
            "VpcInternetGateway",
            tags=[core.CfnTag(key="Name", value="{}/Vpc".format(core.Aws.STACK_NAME))]
        )
        vpc_igw.cfn_options.condition=vpc_not_given_condition
        vpc_igw_attachment = aws_ec2.CfnVPCGatewayAttachment(
            self,
            "VpcIGWAttachment",
            vpc_id=vpc.ref,
            internet_gateway_id=vpc_igw.ref
        )
        vpc_igw_attachment.cfn_options.condition=vpc_not_given_condition

        vpc_public_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPublicRouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicRouteTable".format(core.Aws.STACK_NAME))]
        )
        vpc_public_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_public_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPublicDefaultRoute",
            route_table_id=vpc_public_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            gateway_id=vpc_igw.ref
        )
        vpc_public_default_route.cfn_options.condition=vpc_not_given_condition

        vpc_public_subnet1 = aws_ec2.CfnSubnet(
            self,
            "VpcPublicSubnet1",
            cidr_block="10.0.0.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(0, core.Fn.get_azs()),
            map_public_ip_on_launch=True,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet1".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_public_subnet1.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPublicSubnet1RouteTableAssociation",
            route_table_id=vpc_public_route_table.ref,
            subnet_id=vpc_public_subnet1.ref
        )
        vpc_public_subnet1_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_eip = aws_ec2.CfnEIP(
            self,
            "VpcPublicSubnet1EIP",
            domain="vpc"
        )
        vpc_public_subnet1_eip.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_nat_gateway = aws_ec2.CfnNatGateway(
            self,
            "VpcPublicSubnet1NATGateway",
            allocation_id=vpc_public_subnet1_eip.attr_allocation_id,
            subnet_id=vpc_public_subnet1.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet1".format(core.Aws.STACK_NAME))]
        )
        vpc_public_subnet1_nat_gateway.cfn_options.condition=vpc_not_given_condition

        vpc_public_subnet2 = aws_ec2.CfnSubnet(
            self,
            "VpcPublicSubnet2",
            cidr_block="10.0.64.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(1, core.Fn.get_azs()),
            map_public_ip_on_launch=True,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet2".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_public_subnet2.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPublicSubnet2RouteTableAssociation",
            route_table_id=vpc_public_route_table.ref,
            subnet_id=vpc_public_subnet2.ref
        )
        vpc_public_subnet2_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_eip = aws_ec2.CfnEIP(
            self,
            "VpcPublicSubnet2EIP",
            domain="vpc"
        )
        vpc_public_subnet2_eip.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_nat_gateway = aws_ec2.CfnNatGateway(
            self,
            "VpcPublicSubnet2NATGateway",
            allocation_id=vpc_public_subnet2_eip.attr_allocation_id,
            subnet_id=vpc_public_subnet1.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet2".format(core.Aws.STACK_NAME))]
        )
        vpc_public_subnet2_nat_gateway.cfn_options.condition=vpc_not_given_condition

        vpc_private_subnet1 = aws_ec2.CfnSubnet(
            self,
            "VpcPrivateSubnet1",
            cidr_block="10.0.128.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(0, core.Fn.get_azs()),
            map_public_ip_on_launch=False,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet1".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_private_subnet1.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPrivateSubnet1RouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet1".format(core.Aws.STACK_NAME))]
        )
        vpc_private_subnet1_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPrivateSubnet1RouteTableAssociation",
            route_table_id=vpc_private_subnet1_route_table.ref,
            subnet_id=vpc_private_subnet1.ref
        )
        vpc_private_subnet1_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPrivateSubnet1DefaultRoute",
            route_table_id=vpc_private_subnet1_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            nat_gateway_id=vpc_public_subnet1_nat_gateway.ref
        )
        vpc_private_subnet1_default_route.cfn_options.condition=vpc_not_given_condition

        vpc_private_subnet2 = aws_ec2.CfnSubnet(
            self,
            "VpcPrivateSubnet2",
            cidr_block="10.0.192.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(1, core.Fn.get_azs()),
            map_public_ip_on_launch=False,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet2".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_private_subnet2.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPrivateSubnet2RouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet2".format(core.Aws.STACK_NAME))]
        )
        vpc_private_subnet2_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPrivateSubnet2RouteTableAssociation",
            route_table_id=vpc_private_subnet2_route_table.ref,
            subnet_id=vpc_private_subnet2.ref
        )
        vpc_private_subnet2_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPrivateSubnet2DefaultRoute",
            route_table_id=vpc_private_subnet2_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            nat_gateway_id=vpc_public_subnet2_nat_gateway.ref
        )
        vpc_private_subnet2_default_route.cfn_options.condition=vpc_not_given_condition

        app_sg = aws_ec2.CfnSecurityGroup(
            self,
            "AppSg",
            group_description="App SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        db_sg = aws_ec2.CfnSecurityGroup(
            self,
            "DbSg",
            group_description="Database SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        db_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "DbSgIngress",
            from_port=3306,
            group_id=db_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=3306
        )
        db_subnet_group = aws_rds.CfnDBSubnetGroup(
            self,
            "DbSubnetGroup",
            db_subnet_group_description="MySQL Aurora DB Subnet Group",
            subnet_ids=core.Token.as_list(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    [
                        vpc_private_subnet1.ref,
                        vpc_private_subnet2.ref
                    ],
                    [
                        vpc_private_subnet_id1_param.value_as_string,
                        vpc_private_subnet_id2_param.value_as_string
                    ]
                )
            )
        )
        db_cluster_parameter_group = aws_rds.CfnDBClusterParameterGroup(
            self,
            "DbClusterParameterGroup",
            description="test",
            family="aurora-mysql5.7",
            parameters={
                "character_set_client": "utf8",
                "character_set_connection": "utf8",
                "character_set_database": "utf8",
                "character_set_filesystem": "utf8",
                "character_set_results": "utf8",
                "character_set_server": "utf8",
                "collation_connection": "utf8_general_ci",
                "collation_server": "utf8_general_ci"
            }
        )
        db_parameter_group = aws_rds.CfnDBParameterGroup(
            self,
            "DbParameterGroup",
            description="Aurora DB Instance Parameter Group",
            family="aurora-mysql5.7",
            parameters={
                "general_log": "1",
                "log_output": "FILE",
                "log_queries_not_using_indexes": "1",
                "long_query_time": "10",
                "slow_query_log": "1"
            }
        )
        db_snapshot_identifier_param = core.CfnParameter(
            self,
            "DbSnapshotIdentifier",
            default="",
            description="Optional: RDS snapshot ARN from which to restore. If specified, manually edit the secret values to specify the snapshot credentials for the application. WARNING: Changing this value will re-provision the database."
        )
        db_instance_class_param = core.CfnParameter(
            self,
            "DbInstanceClass",
            allowed_values=allowed_values["allowed_db_instance_types"],
            default="db.r5.large",
            description="Required: The class profile for memory and compute capacity for the database instance."
        )
        db_snapshot_identifier_exists_condition = core.CfnCondition(
            self,
            "DbSnapshotIdentifierExistsCondition",
            expression=core.Fn.condition_not(core.Fn.condition_equals(db_snapshot_identifier_param.value, ""))
        )
        secret_arn_param = core.CfnParameter(
            self,
            "SecretArn",
            default="",
            description="Optional: SecretsManager secret ARN used to store database credentials and other configuration. If not specified, a secret will be created."
        )
        secret_arn_exists_condition = core.CfnCondition(
            self,
            "SecretArnExistsCondition",
            expression=core.Fn.condition_not(core.Fn.condition_equals(secret_arn_param.value, ""))
        )
        secret_arn_not_exists_condition = core.CfnCondition(
            self,
            "SecretArnNotExistsCondition",
            expression=core.Fn.condition_equals(secret_arn_param.value, "")
        )
        secret = aws_secretsmanager.CfnSecret(
            self,
            "Secret",
            generate_secret_string=aws_secretsmanager.CfnSecret.GenerateSecretStringProperty(
                exclude_characters="\"@/\\\"'$,[]*?{}~\#%<>|^",
                exclude_punctuation=True,
                generate_string_key="password",
                secret_string_template=json.dumps({"username":"dbadmin"})
            ),
            name="{}/drupal/secret".format(core.Aws.STACK_NAME)
        )
        secret.cfn_options.condition = secret_arn_not_exists_condition
        db_snapshot_secret_rule = core.CfnRule(
            self,
            "DbSnapshotIdentifierAndSecretRequiredRule",
            assertions=[
                core.CfnRuleAssertion(
                    assert_=core.Fn.condition_not(core.Fn.condition_equals(secret_arn_param.value_as_string, "")),
                    assert_description="When restoring the database from a snapshot, a secret ARN must also be supplied, prepopulated with username and password key-value pairs which correspond to the snapshot image"
                )
            ],
            rule_condition=core.Fn.condition_not(
                core.Fn.condition_equals(db_snapshot_identifier_param.value_as_string, "")
            )
        )

        db_cluster = aws_rds.CfnDBCluster(
            self,
            "DbCluster",
            db_cluster_parameter_group_name=db_cluster_parameter_group.ref,
            db_subnet_group_name=db_subnet_group.ref,
            engine="aurora-mysql",
            engine_mode="provisioned",
            engine_version="5.7.mysql_aurora.2.08.0",
            master_username=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    core.Fn.condition_if(
                        secret_arn_exists_condition.logical_id,
                        core.Fn.sub("{{resolve:secretsmanager:${SecretArn}:SecretString:username}}"),
                        core.Fn.sub("{{resolve:secretsmanager:${Secret}:SecretString:username}}")
                    ),
                )
            ),
            master_user_password=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    core.Fn.condition_if(
                        secret_arn_exists_condition.logical_id,
                        core.Fn.sub("{{resolve:secretsmanager:${SecretArn}:SecretString:password}}"),
                        core.Fn.sub("{{resolve:secretsmanager:${Secret}:SecretString:password}}"),
                    ),
                )
            ),
            snapshot_identifier=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    db_snapshot_identifier_param.value_as_string,
                    core.Aws.NO_VALUE
                )
            ),
            storage_encrypted=True,
            vpc_security_group_ids=[ db_sg.ref ]
        )
        db_primary_instance = aws_rds.CfnDBInstance(
            self,
            "DbPrimaryInstance",
            db_cluster_identifier=db_cluster.ref,
            db_instance_class=db_instance_class_param.value_as_string,
            db_instance_identifier=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    append_stack_uuid("drupal")
                )
            ),
            db_parameter_group_name=db_parameter_group.ref,
            db_subnet_group_name=db_subnet_group.ref,
            engine="aurora-mysql",
            # option_group_name="TODO",
            publicly_accessible=False
        )
        alb_sg = aws_ec2.CfnSecurityGroup(
            self,
            "AlbSg",
            group_description="Alb Sg",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        alb_http_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpIngress",
            cidr_ip="0.0.0.0/0",
            description="Allow from anyone on port 80",
            from_port=80,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=80
        )
        alb_https_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpsIngress",
            cidr_ip="0.0.0.0/0",
            description="Allow from anyone on port 443",
            from_port=443,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=443
        )
        alb = aws_elasticloadbalancingv2.CfnLoadBalancer(
            self,
            "AppAlb",
            scheme="internet-facing",
            security_groups=[ alb_sg.ref ],
            subnets=core.Token.as_list(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    [
                        vpc_public_subnet1.ref,
                        vpc_public_subnet2.ref
                    ],
                    [
                        vpc_public_subnet_id1_param.value_as_string,
                        vpc_public_subnet_id2_param.value_as_string
                    ]
                )
            ),
            type="application"
        )
        alb_dns_name_output = core.CfnOutput(
            self,
            "AlbDnsNameOutput",
            description="The DNS name of the application load balancer.",
            value=alb.attr_dns_name
        )
        # if there is no cert...
        http_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "AsgHttpTargetGroup",
            health_check_enabled=None,
            health_check_interval_seconds=None,
            port=80,
            protocol="HTTP",
            target_type="instance",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        http_target_group.cfn_options.condition = certificate_arn_does_not_exist_condition
        http_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=http_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=alb.ref,
            port=80,
            protocol="HTTP"
        )
        http_listener.cfn_options.condition = certificate_arn_does_not_exist_condition

        # if there is a cert...
        http_redirect_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpRedirectListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    redirect_config=aws_elasticloadbalancingv2.CfnListener.RedirectConfigProperty(
                        host="#{host}",
                        path="/#{path}",
                        port="443",
                        protocol="HTTPS",
                        query="#{query}",
                        status_code="HTTP_301"
                    ),
                    type="redirect"
                ),
            ],
            load_balancer_arn=alb.ref,
            port=80,
            protocol="HTTP"
        )
        http_redirect_listener.cfn_options.condition = certificate_arn_exists_condition
        https_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "AsgHttpsTargetGroup",
            health_check_enabled=None,
            health_check_interval_seconds=None,
            port=443,
            protocol="HTTPS",
            target_type="instance",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        https_target_group.cfn_options.condition = certificate_arn_exists_condition
        https_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpsListener",
            certificates=[
                aws_elasticloadbalancingv2.CfnListener.CertificateProperty(
                    certificate_arn=certificate_arn_param.value_as_string
                )
            ],
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=https_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=alb.ref,
            port=443,
            protocol="HTTPS"
        )
        https_listener.cfn_options.condition = certificate_arn_exists_condition

        # notifications
        notification_topic = aws_sns.CfnTopic(
            self,
            "NotificationTopic",
            topic_name="{}-notifications".format(core.Aws.STACK_NAME)
        )
        notification_subscription = aws_sns.CfnSubscription(
            self,
            "NotificationSubscription",
            protocol="email",
            topic_arn=notification_topic.ref,
            endpoint=notification_email_param.value_as_string
        )
        notification_subscription.cfn_options.condition = notification_email_exists_condition
        iam_notification_publish_policy =aws_iam.PolicyDocument(
            statements=[
                aws_iam.PolicyStatement(
                    effect=aws_iam.Effect.ALLOW,
                    actions=[ "sns:Publish" ],
                    resources=[ notification_topic.ref ]
                )
            ]
        )

        system_log_group = aws_logs.CfnLogGroup(
            self,
            "DrupalSystemLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        system_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        system_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        access_log_group = aws_logs.CfnLogGroup(
            self,
            "DrupalAccessLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        access_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        access_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        error_log_group = aws_logs.CfnLogGroup(
            self,
            "DrupalErrorLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        error_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        error_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN

        # efs
        efs_sg = aws_ec2.CfnSecurityGroup(
            self,
            "EfsSg",
            group_description="EFS SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        efs_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "EfsSgIngress",
            from_port=2049,
            group_id=efs_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=2049
        )
        efs = aws_efs.CfnFileSystem(
            self,
            "AppEfs",
            encrypted=True
        )
        efs_mount_target1 = aws_efs.CfnMountTarget(
            self,
            "AppEfsMountTarget1",
            file_system_id=efs.ref,
            security_groups=[ efs_sg.ref ],
            subnet_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc_private_subnet1.ref,
                    vpc_private_subnet_id1_param.value_as_string
                )
            )
        )
        efs_mount_target2 = aws_efs.CfnMountTarget(
            self,
            "AppEfsMountTarget2",
            file_system_id=efs.ref,
            security_groups=[ efs_sg.ref ],
            subnet_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc_private_subnet2.ref,
                    vpc_private_subnet_id2_param.value_as_string
                )
            )
        )

        # elasticache
        elasticache_cluster_cache_node_type_param = core.CfnParameter(
            self,
            "ElastiCacheClusterCacheNodeType",
            allowed_values=allowed_values["allowed_cache_instance_types"],
            default="cache.t3.micro",
            description="Required: Instance type for the memcached cluster nodes (only applies when ElastiCache enabled)."
        )
        elasticache_cluster_engine_version_param = core.CfnParameter(
            self,
            "ElastiCacheClusterEngineVersion",
            allowed_values=[ "1.4.14", "1.4.24", "1.4.33", "1.4.34", "1.4.5", "1.5.10", "1.5.16" ],
            default="1.5.16",
            description="Required: The memcached version of the cache cluster (only applies when ElastiCache enabled)."
        )
        elasticache_cluster_num_cache_nodes_param = core.CfnParameter(
            self,
            "ElastiCacheClusterNumCacheNodes",
            default=2,
            description="Required: The number of cache nodes in the memcached cluster (only applies ElastiCache enabled).",
            min_value=1,
            max_value=20,
            type="Number"
        )
        elasticache_enable_param = core.CfnParameter(
            self,
            "ElastiCacheEnable",
            allowed_values=[ "true", "false" ],
            default="false",
            description="Required: Whether to provision ElastiCache memcached cluster."
        )
        elasticache_enable_condition = core.CfnCondition(
            self,
            "ElastiCacheEnableCondition",
            expression=core.Fn.condition_equals(elasticache_enable_param.value, "true")
        )
        elasticache_sg = aws_ec2.CfnSecurityGroup(
            self,
            "ElastiCacheSg",
            group_description="App SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        elasticache_sg.cfn_options.condition = elasticache_enable_condition
        elasticache_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "ElasticacheSgIngress",
            from_port=11211,
            group_id=elasticache_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=11211
        )
        elasticache_sg_ingress.cfn_options.condition = elasticache_enable_condition
        elasticache_subnet_group = core.CfnResource(
            self,
            "ElastiCacheSubnetGroup",
            type="AWS::ElastiCache::SubnetGroup",
            properties={
                "Description": "test",
                "SubnetIds":  {
                    "Fn::If": [
                        vpc_not_given_condition.logical_id,
                        [
                            vpc_private_subnet1.ref,
                            vpc_private_subnet2.ref
                        ],
                        [
                            vpc_private_subnet_id1_param.value_as_string,
                            vpc_private_subnet_id2_param.value_as_string
                        ]
                    ]
                }
            }
        )
        elasticache_subnet_group.cfn_options.condition = elasticache_enable_condition
        elasticache_cluster = aws_elasticache.CfnCacheCluster(
            self,
            "ElastiCacheCluster",
            az_mode="cross-az",
            cache_node_type=elasticache_cluster_cache_node_type_param.value_as_string,
            cache_subnet_group_name=elasticache_subnet_group.ref,
            engine="memcached",
            engine_version=elasticache_cluster_engine_version_param.value_as_string,
            num_cache_nodes=elasticache_cluster_num_cache_nodes_param.value_as_number,
            vpc_security_group_ids=[ elasticache_sg.ref ]
        )
        core.Tag.add(elasticache_cluster, "oe:patterns:drupal:stack", core.Aws.STACK_NAME)
        elasticache_cluster.cfn_options.condition = elasticache_enable_condition
        elasticache_cluster_endpoint_output = core.CfnOutput(
            self,
            "ElastiCacheClusterEndpointOutput",
            condition=elasticache_enable_condition,
            description="The endpoint of the cluster for connection. Configure in Drupal's settings.php.",
            value="{}:{}".format(elasticache_cluster.attr_configuration_endpoint_address,
                                 elasticache_cluster.attr_configuration_endpoint_port)
        )

        # cloudfront
        cloudfront_aliases_param = core.CfnParameter(
            self,
            "CloudFrontAliases",
            default="",
            description="Optional: A list of hostname aliases registered with the CloudFront distribution. If a certificate is supplied, each hostname must validate against the certificate.",
            type="CommaDelimitedList"
        )
        cloudfront_aliases_exist_condition = core.CfnCondition(
            self,
            "CloudFrontAliasesExist",
            expression=core.Fn.condition_not(
                core.Fn.condition_equals(core.Fn.select(0, cloudfront_aliases_param.value_as_list), "")
            )
        )
        cloudfront_certificate_arn_param = core.CfnParameter(
            self,
            "CloudFrontCertificateArn",
            default="",
            description="Optional: The ARN from AWS Certificate Manager for the SSL cert used in CloudFront CDN. Must be in us-east-1 region."
        )
        cloudfront_certificate_arn_exists_condition = core.CfnCondition(
            self,
            "CloudFrontCertificateArnExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(cloudfront_certificate_arn_param.value, ""))
        )
        cloudfront_enable_param = core.CfnParameter(
            self,
            "CloudFrontEnable",
            allowed_values=[ "true", "false" ],
            default="false",
            description="Required: Enable CloudFront CDN support."
        )
        cloudfront_enable_condition = core.CfnCondition(
            self,
            "CloudFrontEnableCondition",
            expression=core.Fn.condition_equals(cloudfront_enable_param.value, "true")
        )
        cloudfront_aliases_certificate_rule = core.CfnRule(
            self,
            "CloudFrontAliasesAndCertificateRequiredRule",
            assertions=[
                core.CfnRuleAssertion(
                    assert_=core.Fn.condition_not(
                        core.Fn.condition_equals(cloudfront_certificate_arn_param.value_as_string, "")
                    ),
                    assert_description="When providing a set of aliases for CloudFront, you must also supply a trusted CloudFrontCertificateArn parameter which validates your authorization to use those domain names"
                )
            ],
            rule_condition=core.Fn.condition_not(
                core.Fn.condition_each_member_equals(cloudfront_aliases_param.value_as_list, "")
            )
        )
        cloudfront_price_class_param = core.CfnParameter(
            self,
            "CloudFrontPriceClass",
            # possible to use a map to make the values more human readable
            allowed_values = [
                "PriceClass_All",
                "PriceClass_200",
                "PriceClass_100"
            ],
            default="PriceClass_All",
            description="Required: Price class to use for CloudFront CDN (only applies when CloudFront enabled)."
        )
        cloudfront_distribution = aws_cloudfront.CfnDistribution(
            self,
            "CloudFrontDistribution",
            distribution_config=aws_cloudfront.CfnDistribution.DistributionConfigProperty(
                aliases=core.Token.as_list(
                    core.Fn.condition_if(
                        cloudfront_aliases_exist_condition.logical_id,
                        cloudfront_aliases_param.value_as_list,
                        core.Aws.NO_VALUE
                    )
                ),
                comment=core.Aws.STACK_NAME,
                default_cache_behavior=aws_cloudfront.CfnDistribution.DefaultCacheBehaviorProperty(
                    allowed_methods=[
                        "DELETE",
                        "GET",
                        "HEAD",
                        "OPTIONS",
                        "PATCH",
                        "POST",
                        "PUT"
                    ],
                    compress=True,
                    default_ttl=86400,
                    forwarded_values=aws_cloudfront.CfnDistribution.ForwardedValuesProperty(
                        cookies=aws_cloudfront.CfnDistribution.CookiesProperty(
                            forward="whitelist",
                            whitelisted_names=[ "SESS*" ]
                        ),
                        headers=[
                            "CloudFront-Forwarded-Proto",
                            "Host",
                            "Origin"
                        ],
                        query_string=True
                    ),
                    min_ttl=0,
                    max_ttl=31536000,
                    target_origin_id="alb",
                    # when alb certificate is supplied, we automatically redirect http traffic to https.
                    # using that as a best-practice pattern, we redirect all traffic at cloudfront as well,
                    # covered either by the default AWS cloudfront cert when no aliases are supplied, or by the
                    # cert of the CloudFrontCertificateArn parameter.
                    viewer_protocol_policy="redirect-to-https"
                ),
                enabled=True,
                origins=[ aws_cloudfront.CfnDistribution.OriginProperty(
                    domain_name=alb.attr_dns_name,
                    id="alb",
                    custom_origin_config=aws_cloudfront.CfnDistribution.CustomOriginConfigProperty(
                        # if there is an ssl cert on the alb, use https only
                        origin_protocol_policy=core.Token.as_string(
                            core.Fn.condition_if(
                                certificate_arn_exists_condition.logical_id,
                                "https-only",
                                "http-only"
                            )
                        ),
                        origin_ssl_protocols=[ "TLSv1.1", "TLSv1.2" ]
                    )
                )],
                price_class=cloudfront_price_class_param.value_as_string,
                viewer_certificate=aws_cloudfront.CfnDistribution.ViewerCertificateProperty(
                    acm_certificate_arn=core.Token.as_string(
                        core.Fn.condition_if(
                            cloudfront_certificate_arn_exists_condition.logical_id,
                            cloudfront_certificate_arn_param.value_as_string,
                            core.Aws.NO_VALUE
                        )
                    ),
                    cloud_front_default_certificate=core.Fn.condition_if(
                        cloudfront_certificate_arn_exists_condition.logical_id,
                        core.Aws.NO_VALUE,
                        True
                    ),
                    minimum_protocol_version=core.Token.as_string(
                        core.Fn.condition_if(
                            cloudfront_certificate_arn_exists_condition.logical_id,
                            "TLSv1.2_2018",
                            core.Aws.NO_VALUE
                        )
                    ),
                    ssl_support_method=core.Token.as_string(
                        core.Fn.condition_if(
                            cloudfront_certificate_arn_exists_condition.logical_id,
                            "sni-only",
                            core.Aws.NO_VALUE
                        )
                    )
                )
            )
        )
        cloudfront_distribution_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="distribution",
                resource_name=cloudfront_distribution.ref,
                service="cloudfront"
            ),
            stack=self
        )
        cloudfront_distribution.cfn_options.condition = cloudfront_enable_condition
        cloudfront_invalidation_lambda_function_role = aws_iam.CfnRole(
            self,
            "CloudFrontInvalidationLambdaFunctionRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("lambda.amazonaws.com") ]
                    )
                ]
            ),
            managed_policy_arns=[
                "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
            ],
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "cloudfront:CreateInvalidation" ],
                                resources=[ cloudfront_distribution_arn ]
                            )
                        ]
                    ),
                    policy_name="CloudFrontInvalidation"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "codepipeline:PutJobSuccessResult",
                                    "codepipeline:PutJobFailureResult"
                                ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="CodePipelineResult"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=iam_notification_publish_policy,
                    policy_name="SnsPublishToNotificationTopic"
                )
            ]
        )
        cloudfront_invalidation_lambda_function_role.cfn_options.condition = cloudfront_enable_condition
        with open("drupal/cloudfront_invalidation_lambda_function_code.py") as f:
            cloudfront_invalidation_lambda_function_code = f.read()
        cloudfront_invalidation_lambda_function = aws_lambda.CfnFunction(
            self,
            "CloudFrontInvalidationLambdaFunction",
            code=aws_lambda.CfnFunction.CodeProperty(
                zip_file=cloudfront_invalidation_lambda_function_code
            ),
            dead_letter_config=aws_lambda.CfnFunction.DeadLetterConfigProperty(
                target_arn=notification_topic.ref
            ),
            environment=aws_lambda.CfnFunction.EnvironmentProperty(
                variables={
                    "CloudFrontDistributionId": cloudfront_distribution.ref,
                }
            ),
            handler="index.lambda_handler",
            role=cloudfront_invalidation_lambda_function_role.attr_arn,
            runtime="python3.7"
        )
        cloudfront_invalidation_lambda_function.cfn_options.condition = cloudfront_enable_condition
        cloudfront_distribution_endpoint_output = core.CfnOutput(
            self,
            "CloudFrontDistributionEndpointOutput",
            condition=cloudfront_enable_condition,
            description="The distribution DNS name endpoint for connection. Configure in Drupal's settings.php.",
            value=cloudfront_distribution.attr_domain_name
        )

        # app
        app_instance_role = aws_iam.CfnRole(
            self,
            "AppInstanceRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("ec2.amazonaws.com") ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "logs:CreateLogStream",
                                    "logs:DescribeLogStreams",
                                    "logs:PutLogEvents"
                                ],
                                resources=[
                                    access_log_group.attr_arn,
                                    error_log_group.attr_arn,
                                    system_log_group.attr_arn
                                ]
                            )
                        ]
                    ),
                    policy_name="AllowStreamLogsToCloudWatch"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "ec2:DescribeVolumes",
                                    "ec2:DescribeTags",
                                    "cloudwatch:GetMetricStatistics",
                                    "cloudwatch:ListMetrics",
                                    "cloudwatch:PutMetricData"
                                ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="AllowStreamMetricsToCloudWatch"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:Get*",
                                    "s3:Head*"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="AllowGetFromArtifactBucket",
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "autoscaling:Describe*" ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="AllowDescribeAutoScaling"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "secretsmanager:GetSecretValue" ],
                                resources=[
                                    core.Token.as_string(
                                        core.Fn.condition_if(
                                            secret_arn_exists_condition.logical_id,
                                            secret_arn_param.value_as_string,
                                            secret.ref
                                        )
                                    )
                                ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "secretsmanager:ListSecrets" ],
                                resources=[ "*" ],
                            ),
                        ]
                    ),
                    policy_name="DrupalSecretAccessPolicy"
                )
            ],
            managed_policy_arns=[
                "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
            ]
        )
        instance_profile = aws_iam.CfnInstanceProfile(
            self,
            "AppInstanceProfile",
            roles=[ app_instance_role.ref ]
        )

        # autoscaling
        app_instance_type_param = core.CfnParameter(
            self,
            "AppLaunchConfigInstanceType",
            allowed_values=allowed_values["allowed_instance_types"],
            default="m5.xlarge",
            description="Required: The EC2 instance type for the application Auto Scaling Group."
        )
        asg_desired_capacity_param = core.CfnParameter(
            self,
            "AppAsgDesiredCapacity",
            default=1,
            description="Required: The desired capacity of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        asg_max_size_param = core.CfnParameter(
            self,
            "AppAsgMaxSize",
            default=2,
            description="Required: The maximum size of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        asg_min_size_param = core.CfnParameter(
            self,
            "AppAsgMinSize",
            default=1,
            description="Required: The minimum size of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        with open("drupal/app_launch_config_user_data.sh") as f:
            app_launch_config_user_data = f.read()
        launch_config = aws_autoscaling.CfnLaunchConfiguration(
            self,
            "AppLaunchConfig",
            image_id=core.Fn.find_in_map("AWSAMIRegionMap", core.Aws.REGION, "OEDRUPAL"),
            instance_type=app_instance_type_param.value_as_string,
            iam_instance_profile=instance_profile.ref,
            security_groups=[app_sg.ref],
            user_data=(
                core.Fn.base64(
                    core.Fn.sub(
                        app_launch_config_user_data,
                        {
                            "CloudFrontHost": core.Token.as_string(
                                core.Fn.condition_if(
                                    cloudfront_enable_condition.logical_id,
                                    core.Fn.condition_if(
                                        cloudfront_aliases_exist_condition.logical_id,
                                        core.Fn.select(0, cloudfront_aliases_param.value_as_list),
                                        cloudfront_distribution.attr_domain_name
                                    ),
                                    ""
                                )
                            ),
                            "DrupalSalt": core.Fn.base64(core.Aws.STACK_ID),
                            "ElastiCacheClusterHost": core.Token.as_string(
                                core.Fn.condition_if(
                                    elasticache_enable_condition.logical_id,
                                    elasticache_cluster.attr_configuration_endpoint_address,
                                    ""
                                )
                            ),
                            "ElastiCacheClusterPort": core.Token.as_string(
                                core.Fn.condition_if(
                                    elasticache_enable_condition.logical_id,
                                    elasticache_cluster.attr_configuration_endpoint_port,
                                    ""
                                )
                            ),
                            "SecretArn": core.Token.as_string(
                                core.Fn.condition_if(
                                    secret_arn_exists_condition.logical_id,
                                    secret_arn_param.value_as_string,
                                    secret.ref
                                )
                            )
                        }
                    )
                )
            )
        )
        asg = aws_autoscaling.CfnAutoScalingGroup(
            self,
            "AppAsg",
            launch_configuration_name=launch_config.ref,
            desired_capacity=core.Token.as_string(asg_desired_capacity_param.value),
            max_size=core.Token.as_string(asg_max_size_param.value),
            min_size=core.Token.as_string(asg_min_size_param.value),
            target_group_arns=[
                core.Token.as_string(
                    core.Fn.condition_if(
                        certificate_arn_exists_condition.logical_id,
                        https_target_group.ref,
                        http_target_group.ref
                    )
                )
            ],
            vpc_zone_identifier=core.Token.as_list(
                core.Fn.condition_if(
                    vpc_given_condition.logical_id,
                    [
                        vpc_private_subnet_id1_param.value_as_string,
                        vpc_private_subnet_id2_param.value_as_string
                    ],
                    [
                        vpc_private_subnet1.ref,
                        vpc_private_subnet2.ref
                    ]
                )
            )
        )
        asg.cfn_options.creation_policy=core.CfnCreationPolicy(
            resource_signal=core.CfnResourceSignal(
                count=1,
                timeout="PT15M"
            )
        )
        asg.cfn_options.update_policy=core.CfnUpdatePolicy(
            auto_scaling_rolling_update=core.CfnAutoScalingRollingUpdate(
                min_instances_in_service=1,
                pause_time="PT15M",
                wait_on_resource_signals=True
            ),
            auto_scaling_scheduled_action=core.CfnAutoScalingScheduledAction(
                ignore_unmodified_group_size_properties=True
            )
        )
        core.Tag.add(asg, "Name", "{}/AppAsg".format(core.Aws.STACK_NAME))
        asg.add_depends_on(db_cluster)
        asg_web_server_scale_up_policy = aws_autoscaling.CfnScalingPolicy(
            self,
            "WebServerScaleUpPolicy",
            adjustment_type="ChangeInCapacity",
            auto_scaling_group_name=asg.ref,
            cooldown="60",
            scaling_adjustment=1
        )
        asg_web_server_scale_down_policy = aws_autoscaling.CfnScalingPolicy(
            self,
            "WebServerScaleDownPolicy",
            adjustment_type="ChangeInCapacity",
            auto_scaling_group_name=asg.ref,
            cooldown="60",
            scaling_adjustment=-1
        )

        # cloudwatch alarms
        cpu_alarm_high = aws_cloudwatch.CfnAlarm(
            self,
            "CpuAlarmHigh",
            comparison_operator="GreaterThanThreshold",
            evaluation_periods=2,
            actions_enabled=None,
            alarm_actions=[ asg_web_server_scale_up_policy.ref, notification_topic.ref ],
            alarm_description="Scale-up if CPU > 90% for 10mins",
            dimensions=[ aws_cloudwatch.CfnAlarm.DimensionProperty(
                name="AutoScalingGroupName",
                value=asg.ref
            )],
            metric_name="CPUUtilization",
            namespace="AWS/EC2",
            period=300,
            statistic="Average",
            threshold=90
        )
        cpu_alarm_low = aws_cloudwatch.CfnAlarm(
            self,
            "CpuAlarmLow",
            comparison_operator="LessThanThreshold",
            evaluation_periods=2,
            actions_enabled=None,
            alarm_actions=[ asg_web_server_scale_down_policy.ref, notification_topic.ref ],
            alarm_description="Scale-down if CPU < 70% for 10mins",
            dimensions=[ aws_cloudwatch.CfnAlarm.DimensionProperty(
                name="AutoScalingGroupName",
                value=asg.ref
            )],
            metric_name="CPUUtilization",
            namespace="AWS/EC2",
            period=300,
            statistic="Average",
            threshold=70
        )

        sg_http_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AppSgHttpIngress",
            from_port=80,
            group_id=app_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=alb_sg.ref,
            to_port=80
        )
        sg_http_ingress.cfn_options.condition = certificate_arn_does_not_exist_condition

        sg_https_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AppSgHttpsIngress",
            from_port=443,
            group_id=app_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=alb_sg.ref,
            to_port=443
        )
        sg_https_ingress.cfn_options.condition = certificate_arn_exists_condition

        # codebuild
        codebuild_transform_service_role = aws_iam.CfnRole(
            self,
            "CodeBuildTransformServiceRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("codebuild.amazonaws.com") ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "logs:CreateLogGroup",
                                    "logs:CreateLogStream",
                                    "logs:PutLogEvents"
                                ],
                                resources=[ "*" ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:GetObject",
                                    "s3:PutObject"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="TransformRolePermssions"
                )
            ]
        )
        codebuild_transform_service_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codebuild_transform_service_role.ref,
                service="iam"
            ),
            stack=self
        )
        with open("drupal/codebuild_transform_project_buildspec.yml") as f:
            codebuild_transform_project_buildspec = f.read()
        codebuild_transform_project = aws_codebuild.CfnProject(
            self,
            "CodeBuildTransformProject",
            artifacts=aws_codebuild.CfnProject.ArtifactsProperty(
                type="CODEPIPELINE",
            ),
            environment=aws_codebuild.CfnProject.EnvironmentProperty(
                compute_type="BUILD_GENERAL1_SMALL",
                environment_variables=[
                    aws_codebuild.CfnProject.EnvironmentVariableProperty(
                        name="AUTO_SCALING_GROUP_NAME",
                        value=asg.ref,
                    )
                ],
                image="aws/codebuild/standard:4.0",
                type="LINUX_CONTAINER"
            ),
            name="{}-transform".format(core.Aws.STACK_NAME),
            service_role=codebuild_transform_service_role_arn,
            source=aws_codebuild.CfnProject.SourceProperty(
                build_spec=codebuild_transform_project_buildspec,
                type="CODEPIPELINE"
            )
        )

        # codepipeline
        # TODO: Tighten role / use managed roles?
        codepipeline_role = aws_iam.CfnRole(
            self,
            "PipelineRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("codepipeline.amazonaws.com") ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "codebuild:BatchGetBuilds",
                                    "codebuild:StartBuild",
                                    "codedeploy:GetApplication",
                                    "codedeploy:GetDeploymentGroup",
                                    "codedeploy:ListApplications",
                                    "codedeploy:ListDeploymentGroups",
                                    "codepipeline:*",
                                    "iam:ListRoles",
                                    "iam:PassRole",
                                    "lambda:GetFunctionConfiguration",
                                    "lambda:ListFunctions",
                                    "s3:CreateBucket",
                                    "s3:GetBucketPolicy",
                                    "s3:GetObject",
                                    "s3:ListAllMyBuckets",
                                    "s3:ListBucket",
                                    "s3:PutBucketPolicy"
                                ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="CodePipelinePerms"
                )
            ]
        )
        codepipeline_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codepipeline_role.ref,
                service="iam"
            ),
            stack=self
        )
        codepipeline_source_stage_role = aws_iam.CfnRole(
            self,
            "SourceStageRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ArnPrincipal(codepipeline_role_arn) ]
                    )
                ],
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:Get*",
                                    "s3:Head*"
                                ],
                                resources=[ source_artifact_object_key_arn ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "s3:GetBucketVersioning" ],
                                resources=[
                                    core.Arn.format(
                                        components=core.ArnComponents(
                                            account="",
                                            region="",
                                            resource=source_artifact_bucket_name,
                                            service="s3"
                                        ),
                                        stack=self
                                    )
                                ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "s3:*" ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="SourceRolePerms"
                )
            ]
        )
        codepipeline_source_stage_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codepipeline_source_stage_role.ref,
                service="iam"
            ),
            stack=self
        )
        codepipeline_deploy_stage_role = aws_iam.CfnRole(
            self,
            "DeployStageRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals= [ aws_iam.ArnPrincipal(codepipeline_role_arn) ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "codedeploy:*" ],
                                resources=[ "*" ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:Get*",
                                    "s3:Head*",
                                    "s3:PutObject"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="DeployRolePerms"
                )
            ]
        )
        codepipeline_deploy_stage_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codepipeline_deploy_stage_role.ref,
                service="iam"
            ),
            stack=self
        )
        codepipeline_finalize_stage_role = aws_iam.CfnRole(
           self,
           "CodePipelineFinalizeStageRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ArnPrincipal(codepipeline_role_arn) ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "codedeploy:*" ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="CodeDeploy"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "lambda:InvokeFunction" ],
                                resources=[ cloudfront_invalidation_lambda_function.attr_arn ]
                            )
                        ]
                    ),
                    policy_name="InvokeCloudFrontInvalidationLambdaFunction",
                )
            ]
        )
        codepipeline_finalize_stage_role.cfn_options.condition = cloudfront_enable_condition
        codepipeline_finalize_stage_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codepipeline_finalize_stage_role.ref,
                service="iam"
            ),
            stack=self
        )

        codedeploy_application = aws_codedeploy.CfnApplication(
            self,
            "CodeDeployApplication",
            application_name=core.Aws.STACK_NAME,
            compute_platform="Server"
        )
        codedeploy_role = aws_iam.CfnRole(
             self,
            "CodeDeployRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("codedeploy.{}.amazonaws.com".format(core.Aws.REGION)) ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:GetObject",
                                    "s3:PutObject"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            ),
                        ]
                    ),
                    policy_name="DeployRolePermssions"
                )
            ],
            managed_policy_arns=[ "arn:aws:iam::aws:policy/service-role/AWSCodeDeployRole" ]
        )
        codedeploy_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codedeploy_role.ref,
                service="iam"
            ),
            stack=self
        )
        codedeploy_deployment_group = aws_codedeploy.CfnDeploymentGroup(
            self,
            "CodeDeployDeploymentGroup",
            application_name=codedeploy_application.application_name,
            auto_scaling_groups=[ asg.ref ],
            deployment_group_name="{}-app".format(core.Aws.STACK_NAME),
            deployment_config_name=aws_codedeploy.ServerDeploymentConfig.ALL_AT_ONCE.deployment_config_name,
            service_role_arn=codedeploy_role_arn,
            trigger_configurations=[
                aws_codedeploy.CfnDeploymentGroup.TriggerConfigProperty(
                    trigger_events=[
                        "DeploymentSuccess",
                        "DeploymentRollback"
                    ],
                    trigger_name="DeploymentNotification",
                    trigger_target_arn=notification_topic.ref
                )
            ]
        )
        codepipeline = aws_codepipeline.CfnPipeline(
            self,
            "Pipeline",
            artifact_store=aws_codepipeline.CfnPipeline.ArtifactStoreProperty(
                location=core.Token.as_string(
                    core.Fn.condition_if(
                        pipeline_artifact_bucket_name_exists_condition.logical_id,
                        pipeline_artifact_bucket_name_param.value_as_string,
                        pipeline_artifact_bucket.ref
                    )
                ),
                type="S3"
            ),
            role_arn=codepipeline_role_arn,
            stages=[
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Source",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Source",
                                owner="AWS",
                                provider="S3",
                                version="1"
                            ),
                            configuration={
                                "S3Bucket": source_artifact_bucket_name,
                                "S3ObjectKey": source_artifact_object_key_param.value_as_string
                            },
                            output_artifacts=[
                                aws_codepipeline.CfnPipeline.OutputArtifactProperty(
                                    name="build"
                                )
                            ],
                            name="SourceAction",
                            role_arn=codepipeline_source_stage_role_arn
                        )
                    ]
                ),
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Transform",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Build",
                                owner="AWS",
                                provider="CodeBuild",
                                version="1"
                            ),
                            configuration={
                                "ProjectName": codebuild_transform_project.ref
                            },
                            input_artifacts=[
                                aws_codepipeline.CfnPipeline.InputArtifactProperty(
                                    name="build",
                                )
                            ],
                            name="TransformAction",
                            output_artifacts=[
                                aws_codepipeline.CfnPipeline.OutputArtifactProperty(
                                    name="transformed"
                                )
                            ]
                        )
                    ]
                ),
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Deploy",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Deploy",
                                owner="AWS",
                                provider="CodeDeploy",
                                version="1"
                            ),
                            configuration={
                                "ApplicationName": codedeploy_application.ref,
                                "DeploymentGroupName": codedeploy_deployment_group.ref,
                            },
                            input_artifacts=[
                                aws_codepipeline.CfnPipeline.InputArtifactProperty(
                                    name="transformed"
                                )
                            ],
                            name="DeployAction",
                            role_arn=codepipeline_deploy_stage_role_arn
                        )
                    ]
                )
            ]
        )
        # https://github.com/aws/aws-cdk/issues/8396
        codepipeline.add_override(
            "Properties.Stages.3",
            {
                "Fn::If": [
                    cloudfront_enable_condition.logical_id,
                    {
                        "Actions": [
                            {
                                "ActionTypeId": {
                                    "Category": "Invoke",
                                    "Owner": "AWS",
                                    "Provider": "Lambda",
                                    "Version": "1"
                                },
                                "Configuration": {
                                    "FunctionName": cloudfront_invalidation_lambda_function.ref
                                },
                                "Name": "CloudFrontInvalidationAction",
                                "RoleArn": codepipeline_finalize_stage_role_arn
                            }
                        ],
                        "Name": "Finalize"
                    },
                    core.Aws.NO_VALUE
                ]
            }
        )
        cloudfront_invalidation_lambda_permission = aws_lambda.CfnPermission(
            self,
            "CloudFrontInvalidationLambdaPermission",
            action="lambda:InvokeFunction",
            function_name=cloudfront_invalidation_lambda_function.attr_arn,
            principal="events.amazonaws.com",
            source_arn=codepipeline_role_arn
        )
        cloudfront_invalidation_lambda_permission.cfn_options.condition = cloudfront_enable_condition

        # default drupal
        initialize_default_drupal_param = core.CfnParameter(
            self,
            "InitializeDefaultDrupal",
            allowed_values=[ "true", "false" ],
            default="true",
            description="Optional: Trigger the first deployment with a copy of an initial default codebase from Ordinary Experts using Drupal 9 and some common modules taking advantage of the stack capabilities."
        )
        initialize_default_drupal_condition = core.CfnCondition(
            self,
            "InitializeDefaultDrupalCondition",
            expression=core.Fn.condition_equals(initialize_default_drupal_param.value, "true")
        )
        initialize_default_drupal_lambda_function_role = aws_iam.CfnRole(
            self,
            "InitializeDefaultDrupalLambdaFunctionRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("lambda.amazonaws.com") ]
                    )
                ]
            ),
            managed_policy_arns=[
                "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
            ],
            policies=[
                # OE default drupal artifact should be public, so no policy needed for s3:GetObject
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "s3:ListBucket" ],
                                resources=[ source_artifact_bucket_arn ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:HeadObject",
                                    "s3:PutObject"
                                ],
                                resources=[ source_artifact_object_key_arn ]
                            )
                        ]
                    ),
                    policy_name="PutDefaultDrupalArtifact"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=iam_notification_publish_policy,
                    policy_name="SnsPublishToNotificationTopic"
                )
            ]
        )
        initialize_default_drupal_lambda_function_role.cfn_options.condition = initialize_default_drupal_condition
        with open("drupal/initialize_default_drupal_lambda_function_code.py") as f:
            initialize_default_drupal_lambda_function_code = f.read()
        initialize_default_drupal_lambda_function = aws_lambda.CfnFunction(
            self,
            "InitializeDefaultDrupalLambdaFunction",
            code=aws_lambda.CfnFunction.CodeProperty(
                zip_file=initialize_default_drupal_lambda_function_code
            ),
            dead_letter_config=aws_lambda.CfnFunction.DeadLetterConfigProperty(
                target_arn=notification_topic.ref
            ),
            environment=aws_lambda.CfnFunction.EnvironmentProperty(
                variables={
                    "DefaultDrupalSourceArtifactBucket": DEFAULT_DRUPAL_SOURCE_BUCKET,
                    "DefaultDrupalSourceArtifactObjectKey": DEFAULT_DRUPAL_SOURCE_OBJECT_KEY,
                    "SourceArtifactBucket": source_artifact_bucket_name,
                    "SourceArtifactObjectKey": source_artifact_object_key_param.value_as_string,
                    "StackName": core.Aws.STACK_NAME
                }
            ),
            handler="index.lambda_handler",
            role=initialize_default_drupal_lambda_function_role.attr_arn,
            runtime="python3.7"
        )
        initialize_default_drupal_lambda_function.cfn_options.condition = initialize_default_drupal_condition
        initialize_default_drupal_custom_resource = aws_cloudformation.CfnCustomResource(
            self,
            "InitializeDefaultDrupalCustomResource",
            service_token=initialize_default_drupal_lambda_function.attr_arn
        )
        initialize_default_drupal_custom_resource.cfn_options.condition = initialize_default_drupal_condition

        # AWS::CloudFormation::Interface
        self.template_options.metadata = {
            "OE::Patterns::TemplateVersion": template_version,
            "AWS::CloudFormation::Interface": {
                "ParameterGroups": [
                    {
                        "Label": {
                            "default": "CI/CD"
                        },
                        "Parameters": [
                            notification_email_param.logical_id,
                            source_artifact_bucket_name_param.logical_id,
                            source_artifact_object_key_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "Data Snapshots"
                        },
                        "Parameters": [
                            db_snapshot_identifier_param.logical_id,
                            db_instance_class_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "Application Config"
                        },
                        "Parameters": [
                            certificate_arn_param.logical_id,
                            secret_arn_param.logical_id,
                            app_instance_type_param.logical_id,
                            asg_min_size_param.logical_id,
                            asg_max_size_param.logical_id,
                            asg_desired_capacity_param.logical_id,
                            initialize_default_drupal_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "ElastiCache memcached"
                        },
                        "Parameters": [
                            elasticache_enable_param.logical_id,
                            elasticache_cluster_engine_version_param.logical_id,
                            elasticache_cluster_cache_node_type_param.logical_id,
                            elasticache_cluster_num_cache_nodes_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "CloudFront"
                        },
                        "Parameters": [
                            cloudfront_enable_param.logical_id,
                            cloudfront_certificate_arn_param.logical_id,
                            cloudfront_aliases_param.logical_id,
                            cloudfront_price_class_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "VPC"
                        },
                        "Parameters": [
                            vpc_id_param.logical_id,
                            vpc_private_subnet_id1_param.logical_id,
                            vpc_private_subnet_id2_param.logical_id,
                            vpc_public_subnet_id1_param.logical_id,
                            vpc_public_subnet_id2_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "Template Development"
                        },
                        "Parameters": [
                            pipeline_artifact_bucket_name_param.logical_id
                        ]
                    }
                ],
                "ParameterLabels": {
                    app_instance_type_param.logical_id: {
                        "default": "Instance Type"
                    },
                    asg_desired_capacity_param.logical_id: {
                        "default": "Auto Scaling Group Desired Capacity"
                    },
                    asg_max_size_param.logical_id: {
                        "default": "Auto Scaling Group Maximum Size"
                    },
                    asg_min_size_param.logical_id: {
                        "default": "Auto Scaling Group Minimum Size"
                    },
                    certificate_arn_param.logical_id: {
                        "default": "ACM Certificate ARN"
                    },
                    cloudfront_aliases_param.logical_id: {
                        "default": "CloudFront Aliases"
                    },
                    cloudfront_certificate_arn_param.logical_id: {
                        "default": "CloudFront ACM Certificate ARN"
                    },
                    cloudfront_enable_param.logical_id: {
                        "default": "Enable CloudFront"
                    },
                    cloudfront_price_class_param.logical_id: {
                        "default": "CloudFront Price Class"
                    },
                    db_snapshot_identifier_param.logical_id: {
                        "default": "RDS Snapshot Identifier"
                    },
                    db_instance_class_param.logical_id: {
                        "default": "RDS Instance Class"
                    },
                    elasticache_cluster_cache_node_type_param.logical_id: {
                        "default": "ElastiCache Cache Node Type"
                    },
                    elasticache_cluster_engine_version_param.logical_id: {
                        "default": "ElastiCache Engine Version"
                    },
                    elasticache_cluster_num_cache_nodes_param.logical_id: {
                        "default": "ElastiCache Num Nodes"
                    },
                    elasticache_enable_param.logical_id: {
                        "default": "Enable ElastiCache"
                    },
                    initialize_default_drupal_param.logical_id: {
                        "default": "Initialize with a default Drupal codebase"
                    },
                    notification_email_param.logical_id: {
                        "default": "Notification Email"
                    },
                    pipeline_artifact_bucket_name_param.logical_id: {
                        "default": "CodePipeline Bucket Name"
                    },
                    secret_arn_param.logical_id: {
                        "default": "SecretsManager secret ARN"
                    },
                    source_artifact_bucket_name_param.logical_id: {
                        "default": "Source Artifact S3 Bucket Name"
                    },
                    source_artifact_object_key_param.logical_id: {
                        "default": "Source Artifact S3 Object Key (path)"
                    },
                    vpc_id_param.logical_id: {
                        "default": "VPC ID"
                    },
                    vpc_private_subnet_id1_param.logical_id: {
                        "default": "Private Subnet ID 1"
                    },
                    vpc_private_subnet_id2_param.logical_id: {
                        "default": "Private Subnet ID 2"
                    },
                    vpc_public_subnet_id1_param.logical_id: {
                        "default": "Public Subnet ID 1"
                    },
                    vpc_public_subnet_id2_param.logical_id: {
                        "default": "Public Subnet ID 2"
                    }
                }
            }
        }
