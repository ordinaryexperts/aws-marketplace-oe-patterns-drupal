import json
import os
import yaml
from aws_cdk import (
    aws_autoscaling,
    aws_cloudfront,
    aws_cloudwatch,
    aws_codebuild,
    aws_codedeploy,
    aws_codepipeline,
    aws_codepipeline_actions,
    aws_ec2,
    aws_efs,
    aws_elasticache,
    aws_elasticloadbalancingv2,
    aws_iam,
    aws_logs,
    aws_rds,
    aws_s3,
    aws_secretsmanager,
    aws_sns,
    aws_ssm,
    core
)

TWO_YEARS_IN_DAYS=731

# AMI list generated by:
# make AMI_ID=ami-0fa0106447826c1ff ami-ec2-copy
# on Wed Jun 10 12:40:14 UTC 2020.
AMI_ID="ami-0fa0106447826c1ff"
AMI_NAME="ordinary-experts-patterns-drupal-0.3.0-78-g185aaa2-20200610-1232"
generated_ami_ids = {
    "us-east-2": "ami-0079e4dd11a16a856",
    "us-west-1": "ami-0cfa16449278af8aa",
    "us-west-2": "ami-07672a1ac04377136",
    "ca-central-1": "ami-0b92a9f614244d0bb",
    "eu-central-1": "ami-06ae8a07a34d45a33",
    "eu-west-1": "ami-0ac71359a90541192",
    "eu-west-2": "ami-03ee91af975506ec3",
    "eu-west-3": "ami-010a2635d02d12d3d",
    "ap-northeast-1": "ami-0175b63ce541d29c6",
    "ap-northeast-2": "ami-03bab224e51a788b8",
    "ap-south-1": "ami-01d4cd8aee383edad",
    "ap-southeast-1": "ami-0e32683162e1dc7c4",
    "ap-southeast-2": "ami-0f9c55c7756ee5182",
    "us-east-1": "ami-0fa0106447826c1ff"
}
# End generated code block.

# Sanity check: if this fails then make copy-image needs to be run...
assert AMI_ID == generated_ami_ids["us-east-1"]

class DrupalStack(core.Stack):

    def __init__(self, scope: core.Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        ami_mapping={
            "AMI": {
                "OEDRUPAL": AMI_NAME
            }
        }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "OEDRUPAL": generated_ami_ids[region] }
        aws_ami_region_map = core.CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        # utility function to parse the unique id from the stack id for
        # shorter resource names  using cloudformation functions
        def append_stack_uuid(name):
            return core.Fn.join("-", [
                name,
                core.Fn.select(0, core.Fn.split("-", core.Fn.select(2, core.Fn.split("/", core.Aws.STACK_ID))))
            ])

        pipeline_artifact_bucket_name_param = core.CfnParameter(
            self,
            "PipelineArtifactBucketName",
            default="",
            description="Optional: Specify a bucket name for the CodePipeline pipeline to use. This can be handy when re-creating this template many times."
        )
        pipeline_artifact_bucket_name_not_exists_condition = core.CfnCondition(
            self,
            "PipelineArtifactBucketNameNotExists",
            expression=core.Fn.condition_equals(pipeline_artifact_bucket_name_param.value, "")
        )
        pipeline_artifact_bucket_name_exists_condition = core.CfnCondition(
            self,
            "PipelineArtifactBucketNameExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(pipeline_artifact_bucket_name_param.value, ""))
        )
        pipeline_artifact_bucket = aws_s3.CfnBucket(
            self,
            "PipelineArtifactBucket",
            access_control="Private",
            bucket_encryption=aws_s3.CfnBucket.BucketEncryptionProperty(
                server_side_encryption_configuration=[
                    aws_s3.CfnBucket.ServerSideEncryptionRuleProperty(
                        server_side_encryption_by_default=aws_s3.CfnBucket.ServerSideEncryptionByDefaultProperty(
                            sse_algorithm="AES256"
                        )
                    )
                ]
            ),
            public_access_block_configuration=aws_s3.BlockPublicAccess.BLOCK_ALL
        )
        pipeline_artifact_bucket.cfn_options.condition=pipeline_artifact_bucket_name_not_exists_condition
        pipeline_artifact_bucket.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        pipeline_artifact_bucket.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        source_artifact_s3_bucket_param = core.CfnParameter(
            self,
            "SourceArtifactS3Bucket",
            default="github-user-and-bucket-githubartifactbucket-wl52dae3lyub",
            description="Required: AWS S3 Bucket name which contains the build artifacts for the application.  Default value will deploy Ordinary Experts demo Drupal site."
        )
        source_artifact_s3_object_key_param = core.CfnParameter(
            self,
            "SourceArtifactS3ObjectKey",
            default="aws-marketplace-oe-patterns-drupal-example-site/refs/heads/develop.zip",
            description="Required: AWS S3 Object key (path) for the build artifact for the application.  Default value will deploy Ordinary Experts demo Drupal site."
        )
        notification_email_param = core.CfnParameter(
            self,
            "NotificationEmail",
            default="",
            description="Optional: Specify an email address to get emails about deploys and other system events."
        )
        certificate_arn_param = core.CfnParameter(
            self,
            "CertificateArn",
            default="",
            description="Optional: Specify the ARN of a ACM Certificate to configure HTTPS."
        )
        certificate_arn_exists_condition = core.CfnCondition(
            self,
            "CertificateArnExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(certificate_arn_param.value, ""))
        )
        certificate_arn_does_not_exist_condition = core.CfnCondition(
            self,
            "CertificateArnNotExists",
            expression=core.Fn.condition_equals(certificate_arn_param.value, "")
        )
        notification_email_exists_condition = core.CfnCondition(
            self,
            "NotificationEmailExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(notification_email_param.value, ""))
        )

        # vpc
        vpc_id_param = core.CfnParameter(
            self,
            "VpcId",
            default="",
            description="Optional: Specify the VPC ID.  If not specified, a VPC will be created."
        )
        vpc_private_subnet_id1_param = core.CfnParameter(
            self,
            "VpcPrivateSubnetId1",
            default="",
            description="Optional: Specify Subnet ID for first private subnet."
        )
        vpc_private_subnet_id2_param = core.CfnParameter(
            self,
            "VpcPrivateSubnetId2",
            default="",
            description="Optional: Specify Subnet ID for second private subnet."
        )
        vpc_public_subnet_id1_param = core.CfnParameter(
            self,
            "VpcPublicSubnetId1",
            default="",
            description="Optional: Specify Subnet ID for first public subnet."
        )
        vpc_public_subnet_id2_param = core.CfnParameter(
            self,
            "VpcPublicSubnetId2",
            default="",
            description="Optional: Specify Subnet ID for second public subnet."
        )
        vpc_given_condition = core.CfnCondition(
            self,
            "VpcGiven",
            expression=core.Fn.condition_not(core.Fn.condition_equals(vpc_id_param.value, ""))
        )
        vpc_not_given_condition = core.CfnCondition(
            self,
            "VpcNotGiven",
            expression=core.Fn.condition_equals(vpc_id_param.value, "")
        )
        vpc = aws_ec2.CfnVPC(
            self,
            "Vpc",
            cidr_block="10.0.0.0/16",
            enable_dns_hostnames=True,
            enable_dns_support=True,
            instance_tenancy="default",
            tags=[core.CfnTag(key="Name", value="{}/Vpc".format(core.Aws.STACK_NAME))]
        )
        vpc.cfn_options.condition=vpc_not_given_condition

        vpc_igw = aws_ec2.CfnInternetGateway(
            self,
            "VpcInternetGateway",
            tags=[core.CfnTag(key="Name", value="{}/Vpc".format(core.Aws.STACK_NAME))]
        )
        vpc_igw.cfn_options.condition=vpc_not_given_condition
        vpc_igw_attachment = aws_ec2.CfnVPCGatewayAttachment(
            self,
            "VpcIGWAttachment",
            vpc_id=vpc.ref,
            internet_gateway_id=vpc_igw.ref
        )
        vpc_igw_attachment.cfn_options.condition=vpc_not_given_condition

        vpc_public_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPublicRouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicRouteTable".format(core.Aws.STACK_NAME))]
        )
        vpc_public_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_public_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPublicDefaultRoute",
            route_table_id=vpc_public_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            gateway_id=vpc_igw.ref
        )
        vpc_public_default_route.cfn_options.condition=vpc_not_given_condition

        vpc_public_subnet1 = aws_ec2.CfnSubnet(
            self,
            "VpcPublicSubnet1",
            cidr_block="10.0.0.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(0, core.Fn.get_azs()),
            map_public_ip_on_launch=True,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet1".format(core.Aws.STACK_NAME)),
                core.CfnTag(key="aws-cdk:subnet-name", value="Public"),
                core.CfnTag(key="aws-cdk:subnet-type", value="Public")
            ]
        )
        vpc_public_subnet1.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPublicSubnet1RouteTableAssociation",
            route_table_id=vpc_public_route_table.ref,
            subnet_id=vpc_public_subnet1.ref
        )
        vpc_public_subnet1_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_eip = aws_ec2.CfnEIP(
            self,
            "VpcPublicSubnet1EIP",
            domain="vpc"
        )
        vpc_public_subnet1_eip.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_nat_gateway = aws_ec2.CfnNatGateway(
            self,
            "VpcPublicSubnet1NATGateway",
            allocation_id=vpc_public_subnet1_eip.attr_allocation_id,
            subnet_id=vpc_public_subnet1.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet1".format(core.Aws.STACK_NAME))]
        )
        vpc_public_subnet1_nat_gateway.cfn_options.condition=vpc_not_given_condition

        vpc_public_subnet2 = aws_ec2.CfnSubnet(
            self,
            "VpcPublicSubnet2",
            cidr_block="10.0.64.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(1, core.Fn.get_azs()),
            map_public_ip_on_launch=True,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet2".format(core.Aws.STACK_NAME)),
                core.CfnTag(key="aws-cdk:subnet-name", value="Public"),
                core.CfnTag(key="aws-cdk:subnet-type", value="Public")
            ]
        )
        vpc_public_subnet2.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPublicSubnet2RouteTableAssociation",
            route_table_id=vpc_public_route_table.ref,
            subnet_id=vpc_public_subnet2.ref
        )
        vpc_public_subnet2_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_eip = aws_ec2.CfnEIP(
            self,
            "VpcPublicSubnet2EIP",
            domain="vpc"
        )
        vpc_public_subnet2_eip.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_nat_gateway = aws_ec2.CfnNatGateway(
            self,
            "VpcPublicSubnet2NATGateway",
            allocation_id=vpc_public_subnet2_eip.attr_allocation_id,
            subnet_id=vpc_public_subnet1.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet2".format(core.Aws.STACK_NAME))]
        )
        vpc_public_subnet2_nat_gateway.cfn_options.condition=vpc_not_given_condition

        vpc_private_subnet1 = aws_ec2.CfnSubnet(
            self,
            "VpcPrivateSubnet1",
            cidr_block="10.0.128.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(0, core.Fn.get_azs()),
            map_public_ip_on_launch=False,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet1".format(core.Aws.STACK_NAME)),
                core.CfnTag(key="aws-cdk:subnet-name", value="Private"),
                core.CfnTag(key="aws-cdk:subnet-type", value="Private")
            ]
        )
        vpc_private_subnet1.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPrivateSubnet1RouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet1".format(core.Aws.STACK_NAME))]
        )
        vpc_private_subnet1_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPrivateSubnet1RouteTableAssociation",
            route_table_id=vpc_private_subnet1_route_table.ref,
            subnet_id=vpc_private_subnet1.ref
        )
        vpc_private_subnet1_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPrivateSubnet1DefaultRoute",
            route_table_id=vpc_private_subnet1_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            nat_gateway_id=vpc_public_subnet1_nat_gateway.ref
        )
        vpc_private_subnet1_default_route.cfn_options.condition=vpc_not_given_condition

        vpc_private_subnet2 = aws_ec2.CfnSubnet(
            self,
            "VpcPrivateSubnet2",
            cidr_block="10.0.192.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(1, core.Fn.get_azs()),
            map_public_ip_on_launch=False,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet2".format(core.Aws.STACK_NAME)),
                core.CfnTag(key="aws-cdk:subnet-name", value="Private"),
                core.CfnTag(key="aws-cdk:subnet-type", value="Private")
            ]
        )
        vpc_private_subnet2.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPrivateSubnet2RouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet2".format(core.Aws.STACK_NAME))]
        )
        vpc_private_subnet2_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPrivateSubnet2RouteTableAssociation",
            route_table_id=vpc_private_subnet2_route_table.ref,
            subnet_id=vpc_private_subnet2.ref
        )
        vpc_private_subnet2_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPrivateSubnet2DefaultRoute",
            route_table_id=vpc_private_subnet2_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            nat_gateway_id=vpc_public_subnet2_nat_gateway.ref
        )
        vpc_private_subnet2_default_route.cfn_options.condition=vpc_not_given_condition

        app_sg = aws_ec2.CfnSecurityGroup(
            self,
            "AppSg",
            group_description="App SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        db_sg = aws_ec2.CfnSecurityGroup(
            self,
            "DBSg",
            group_description="Database SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        db_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "DBSgIngress",
            from_port=3306,
            group_id=db_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=3306
        )
        # TODO: move to CfnDBSubnetGroup
        db_subnet_group = core.CfnResource(
            self,
            "DBSubnetGroup",
            type="AWS::RDS::DBSubnetGroup",
            properties={
                "DBSubnetGroupDescription": "MySQL Aurora DB Subnet Group",
                "SubnetIds":  {
                    "Fn::If": [
                        vpc_not_given_condition.logical_id,
                        [
                            vpc_private_subnet1.ref,
                            vpc_private_subnet2.ref
                        ],
                        [
                            vpc_private_subnet_id1_param.value_as_string,
                            vpc_private_subnet_id2_param.value_as_string
                        ]
                    ]
                }
            }
        )
        db_parameter_group = aws_rds.CfnDBParameterGroup(
            self,
            "DBParameterGroup",
            description="Drupal RDS MySQL 5.7 parameter group.",
            family="mysql5.7",
            parameters={
                "character_set_client": "utf8",
                "character_set_connection": "utf8",
                "character_set_database": "utf8",
                "character_set_filesystem": "utf8",
                "character_set_results": "utf8",
                "character_set_server": "utf8",
                "collation_connection": "utf8_general_ci",
                "collation_server": "utf8_general_ci"
            }
        )
        db_allocated_storage_param = core.CfnParameter(
            self,
            "DBAllocatedStorage",
            default="100",
            description="Required: The initial amount of allocated storage in gigabytes for the database instance."
        )
        db_instance_class_param = core.CfnParameter(
            self,
            "DBInstanceClass",
            # https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html
            allowed_values=[ "db.m5.large", "db.m5.xlarge", "db.m5.2xlarge", "db.m5.4xlarge", "db.m5.12xlarge", "db.m5.24xlarge", "db.m4.large", "db.m4.xlarge", "db.m4.2xlarge", "db.m4.4xlarge", "db.m4.10xlarge", "db.m4.16xlarge", "db.r4.large", "db.m3.medium", "db.m3.large", "db.m3.xlarge", "db.m3.2xlarge", "db.r5.large", "db.r5.xlarge", "db.r5.2xlarge", "db.r5.4xlarge", "db.r5.12xlarge", "db.r5.24xlarge", "db.r4.xlarge", "db.r4.2xlarge", "db.r4.4xlarge", "db.r4.8xlarge", "db.r4.16xlarge", "db.r3.large", "db.r3.xlarge", "db.r3.2xlarge", "db.r3.4xlarge", "db.r3.8xlarge", "db.t3.micro", "db.t3.small", "db.t3.medium", "db.t3.large", "db.t3.xlarge", "db.t3.2xlarge", "db.t2.micro", "db.t2.small", "db.t2.medium", "db.t2.large", "db.t2.xlarge", "db.t2.2xlarge" ],
            default="db.t3.large",
            description="Required: The class profile for memory and compute capacity for the database instance."
        )
        db_snapshot_identifier_param = core.CfnParameter(
            self,
            "DBSnapshotIdentifier",
            default="",
            description="Optional: RDS snapshot ARN from which to restore. If specified, manually edit the secret values to specify the snapshot credentials for the application. WARNING: Changing this value will re-provision the database."
        )
        db_snapshot_identifier_exists_condition = core.CfnCondition(
            self,
            "DBSnapshotIdentifierExistsCondition",
            expression=core.Fn.condition_not(core.Fn.condition_equals(db_snapshot_identifier_param.value, ""))
        )
        secret_arn_param = core.CfnParameter(
            self,
            "SecretArn",
            default="",
            description="Optional: SecretsManager secret ARN used to store database credentials and other configuration. If not specified a secret will be created."
        )
        secret_arn_exists_condition = core.CfnCondition(
            self,
            "SecretArnExistsCondition",
            expression=core.Fn.condition_not(core.Fn.condition_equals(secret_arn_param.value, ""))
        )
        secret_arn_not_exists_condition = core.CfnCondition(
            self,
            "SecretArnNotExistsCondition",
            expression=core.Fn.condition_equals(secret_arn_param.value, "")
        )
        secret = aws_secretsmanager.CfnSecret(
            self,
            "Secret",
            generate_secret_string=aws_secretsmanager.CfnSecret.GenerateSecretStringProperty(
                exclude_characters="\"@/\\\"'$,[]*?{}~\#%<>|^",
                exclude_punctuation=True,
                generate_string_key="password",
                secret_string_template=json.dumps({"username":"dbadmin"})
            ),
            name="{}/drupal/secret".format(core.Aws.STACK_NAME)
        )
        secret.cfn_options.condition = secret_arn_not_exists_condition
        secret_policy = aws_iam.Policy(
            self,
            "SecretPolicy",
            statements=[
                aws_iam.PolicyStatement(
                    effect=aws_iam.Effect.ALLOW,
                    actions=[
                        "secretsmanager:GetSecretValue"
                    ],
                    resources=[
                        core.Token.as_string(
                            core.Fn.condition_if(
                                secret_arn_exists_condition.logical_id,
                                secret_arn_param.value_as_string,
                                secret.ref
                            )
                        )
                    ]
                ),
                aws_iam.PolicyStatement(
                    effect=aws_iam.Effect.ALLOW,
                    actions=[ "secretsmanager:ListSecrets" ],
                    resources=[ "*" ],
                ),
            ]
        )
        db_snapshot_secret_rule = core.CfnRule(
            self,
            "DbSnapshotIdentifierAndSecretRequiredRule",
            assertions=[
                core.CfnRuleAssertion(
                    assert_=core.Fn.condition_not(core.Fn.condition_equals(secret_arn_param.value_as_string, "")),
                    assert_description="When restoring the database from a snapshot, a secret ARN must also be supplied, prepopulated with username and password key-value pairs which correspond to the snapshot image"
                )
            ],
            rule_condition=core.Fn.condition_not(
                core.Fn.condition_equals(db_snapshot_identifier_param.value_as_string, "")
            )
        )

        db_instance = aws_rds.CfnDBInstance(
            self,
            "DBInstance",
            allocated_storage=db_allocated_storage_param.value_as_string,
            db_instance_class=db_instance_class_param.value_as_string,
            db_instance_identifier=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    append_stack_uuid("drupal")
                )
            ),
            db_parameter_group_name=db_parameter_group.ref,
            db_snapshot_identifier=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    db_snapshot_identifier_param.value_as_string,
                    core.Aws.NO_VALUE
                )
            ),
            db_subnet_group_name=db_subnet_group.ref,
            engine="mysql",
            engine_version="5.7.28",
            master_username=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    core.Fn.condition_if(
                        secret_arn_exists_condition.logical_id,
                        core.Fn.sub("{{resolve:secretsmanager:${SecretArn}:SecretString:username}}"),
                        core.Fn.sub("{{resolve:secretsmanager:${Secret}:SecretString:username}}")
                    ),
                )
            ),
            master_user_password=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    core.Fn.condition_if(
                        secret_arn_exists_condition.logical_id,
                        core.Fn.sub("{{resolve:secretsmanager:${SecretArn}:SecretString:password}}"),
                        core.Fn.sub("{{resolve:secretsmanager:${Secret}:SecretString:password}}"),
                    ),
                )
            ),
            multi_az=True,
            storage_encrypted=True,
            vpc_security_groups=[ db_sg.ref ]
        )
        alb_sg = aws_ec2.CfnSecurityGroup(
            self,
            "ALBSg",
            group_description="ALB SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        alb_http_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpIngress",
            cidr_ip="0.0.0.0/0",
            description="Allow from anyone on port 80",
            from_port=80,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=80
        )
        alb_https_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpsIngress",
            cidr_ip="0.0.0.0/0",
            description="Allow from anyone on port 443",
            from_port=443,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=443
        )
        alb = aws_elasticloadbalancingv2.CfnLoadBalancer(
            self,
            "AppAlb",
            scheme="internet-facing",
            security_groups=[ alb_sg.ref ],
            subnets=core.Token.as_list(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    [
                        vpc_public_subnet1.ref,
                        vpc_public_subnet2.ref
                    ],
                    [
                        vpc_public_subnet_id1_param.value_as_string,
                        vpc_public_subnet_id2_param.value_as_string
                    ]
                )
            ),
            type="application"
        )
        alb_dns_name_output = core.CfnOutput(
            self,
            "AlbDnsNameOutput",
            description="The DNS name of the application load balancer.",
            value=alb.attr_dns_name
        )
        # if there is no cert...
        http_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "AsgHttpTargetGroup",
            health_check_enabled=None,
            health_check_interval_seconds=None,
            port=80,
            protocol="HTTP",
            target_type="instance",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        http_target_group.cfn_options.condition = certificate_arn_does_not_exist_condition
        http_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=http_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=alb.ref,
            port=80,
            protocol="HTTP"
        )
        http_listener.cfn_options.condition = certificate_arn_does_not_exist_condition

        # if there is a cert...
        http_redirect_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpRedirectListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    redirect_config=aws_elasticloadbalancingv2.CfnListener.RedirectConfigProperty(
                        host="#{host}",
                        path="/#{path}",
                        port="443",
                        protocol="HTTPS",
                        query="#{query}",
                        status_code="HTTP_301"
                    ),
                    type="redirect"
                ),
            ],
            load_balancer_arn=alb.ref,
            port=80,
            protocol="HTTP"
        )
        http_redirect_listener.cfn_options.condition = certificate_arn_exists_condition
        https_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "AsgHttpsTargetGroup",
            health_check_enabled=None,
            health_check_interval_seconds=None,
            port=443,
            protocol="HTTPS",
            target_type="instance",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        https_target_group.cfn_options.condition = certificate_arn_exists_condition
        https_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpsListener",
            certificates=[
                aws_elasticloadbalancingv2.CfnListener.CertificateProperty(
                    certificate_arn=certificate_arn_param.value_as_string
                )
            ],
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=https_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=alb.ref,
            port=443,
            protocol="HTTPS"
        )
        https_listener.cfn_options.condition = certificate_arn_exists_condition

        # notifications
        notification_topic = aws_sns.Topic(
            self,
            "NotificationTopic"
        )
        notification_subscription = aws_sns.CfnSubscription(
            self,
            "NotificationSubscription",
            protocol="email",
            topic_arn=notification_topic.topic_arn,
            endpoint=notification_email_param.value_as_string
        )
        notification_subscription.cfn_options.condition = notification_email_exists_condition

        system_log_group = aws_logs.CfnLogGroup(
            self,
            "DrupalSystemLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        system_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        system_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        access_log_group = aws_logs.CfnLogGroup(
            self,
            "DrupalAccessLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        access_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        access_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        error_log_group = aws_logs.CfnLogGroup(
            self,
            "DrupalErrorLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        error_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        error_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN

        # efs
        efs_sg = aws_ec2.CfnSecurityGroup(
            self,
            "EfsSg",
            group_description="EFS SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        efs_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "EFSSgIngress",
            from_port=2049,
            group_id=efs_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=2049
        )
        efs = aws_efs.CfnFileSystem(
            self,
            "AppEfs",
            encrypted=True
        )
        efs_mount_target1 = aws_efs.CfnMountTarget(
            self,
            "AppEfsMountTarget1",
            file_system_id=efs.ref,
            security_groups=[ efs_sg.ref ],
            subnet_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc_private_subnet1.ref,
                    vpc_private_subnet_id1_param.value_as_string
                )
            )
        )
        efs_mount_target2 = aws_efs.CfnMountTarget(
            self,
            "AppEfsMountTarget2",
            file_system_id=efs.ref,
            security_groups=[ efs_sg.ref ],
            subnet_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc_private_subnet2.ref,
                    vpc_private_subnet_id2_param.value_as_string
                )
            )
        )

        # elasticache
        elasticache_cluster_cache_node_type_param = core.CfnParameter(
            self,
            "ElastiCacheClusterCacheNodeType",
            allowed_values=[ "cache.m5.large", "cache.m5.xlarge", "cache.m5.2xlarge", "cache.m5.4xlarge", "cache.m5.12xlarge", "cache.m5.24xlarge", "cache.m4.large", "cache.m4.xlarge", "cache.m4.2xlarge", "cache.m4.4xlarge", "cache.m4.10xlarge", "cache.t3.micro", "cache.t3.small", "cache.t3.medium", "cache.t2.micro", "cache.t2.small", "cache.t2.medium" ],
            default="cache.t2.micro",
            description="Required: Instance type for the memcached cluster nodes (only applies when ElastiCache enabled)."
        )
        elasticache_cluster_engine_version_param = core.CfnParameter(
            self,
            "ElastiCacheClusterEngineVersion",
            allowed_values=[ "1.4.14", "1.4.24", "1.4.33", "1.4.34", "1.4.5", "1.5.10", "1.5.16" ],
            default="1.5.16",
            description="Required: The memcached version of the cache cluster (only applies when ElastiCache enabled)."
        )
        elasticache_cluster_num_cache_nodes_param = core.CfnParameter(
            self,
            "ElastiCacheClusterNumCacheNodes",
            default=2,
            description="Required: The number of cache nodes in the memcached cluster (only applies ElastiCache enabled).",
            min_value=1,
            max_value=20,
            type="Number"
        )
        elasticache_enable_param = core.CfnParameter(
            self,
            "ElastiCacheEnable",
            allowed_values=[ "true", "false" ],
            default="false",
            description="Required: Whether to provision ElastiCache memcached cluster."
        )
        elasticache_enable_condition = core.CfnCondition(
            self,
            "ElastiCacheEnableCondition",
            expression=core.Fn.condition_equals(elasticache_enable_param.value, "true")
        )
        elasticache_sg = aws_ec2.CfnSecurityGroup(
            self,
            "ElastiCacheSg",
            group_description="App SG",
            vpc_id=core.Token.as_string(
                core.Fn.condition_if(
                    vpc_not_given_condition.logical_id,
                    vpc.ref,
                    vpc_id_param.value_as_string
                )
            )
        )
        elasticache_sg.cfn_options.condition = elasticache_enable_condition
        elasticache_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "ElasticacheSgIngress",
            from_port=11211,
            group_id=elasticache_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=11211
        )
        elasticache_sg_ingress.cfn_options.condition = elasticache_enable_condition
        elasticache_subnet_group = core.CfnResource(
            self,
            "ElastiCacheSubnetGroup",
            type="AWS::ElastiCache::SubnetGroup",
            properties={
                "Description": "test",
                "SubnetIds":  {
                    "Fn::If": [
                        vpc_not_given_condition.logical_id,
                        [
                            vpc_private_subnet1.ref,
                            vpc_private_subnet2.ref
                        ],
                        [
                            vpc_private_subnet_id1_param.value_as_string,
                            vpc_private_subnet_id2_param.value_as_string
                        ]
                    ]
                }
            }
        )
        elasticache_subnet_group.cfn_options.condition = elasticache_enable_condition
        elasticache_cluster = aws_elasticache.CfnCacheCluster(
            self,
            "ElastiCacheCluster",
            az_mode="cross-az",
            cache_node_type=elasticache_cluster_cache_node_type_param.value_as_string,
            cache_subnet_group_name=elasticache_subnet_group.ref,
            engine="memcached",
            engine_version=elasticache_cluster_engine_version_param.value_as_string,
            num_cache_nodes=elasticache_cluster_num_cache_nodes_param.value_as_number,
            vpc_security_group_ids=[ elasticache_sg.ref ]
        )
        core.Tag.add(elasticache_cluster, "oe:patterns:drupal:stack", core.Aws.STACK_NAME)
        elasticache_cluster.cfn_options.condition = elasticache_enable_condition
        elasticache_cluster_endpoint_output = core.CfnOutput(
            self,
            "ElastiCacheClusterEndpointOutput",
            condition=elasticache_enable_condition,
            description="The endpoint of the cluster for connection. Configure in Drupal's settings.php.",
            value="{}:{}".format(elasticache_cluster.attr_configuration_endpoint_address,
                                 elasticache_cluster.attr_configuration_endpoint_port)
        )

        # cloudfront
        cloudfront_aliases_param = core.CfnParameter(
            self,
            "CloudFrontAliases",
            default="",
            description="Optional: A list of hostname aliases registered with the CloudFront distribution. If a certificate is supplied, each hostname must validate against the certificate.",
            type="CommaDelimitedList"
        )
        cloudfront_aliases_exist_condition = core.CfnCondition(
            self,
            "CloudFrontAliasesExist",
            expression=core.Fn.condition_not(
                core.Fn.condition_equals(core.Fn.select(0, cloudfront_aliases_param.value_as_list), "")
            )
        )
        cloudfront_certificate_arn_param = core.CfnParameter(
            self,
            "CloudFrontCertificateArn",
            default="",
            description="Optional: The ARN from AWS Certificate Manager for the SSL cert used in CloudFront CDN. Must be in us-east-1 region."
        )
        cloudfront_certificate_arn_exists_condition = core.CfnCondition(
            self,
            "CloudFrontCertificateArnExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(cloudfront_certificate_arn_param.value, ""))
        )
        cloudfront_enable_param = core.CfnParameter(
            self,
            "CloudFrontEnable",
            allowed_values=[ "true", "false" ],
            default="false",
            description="Required: Enable CloudFront CDN support."
        )
        cloudfront_enable_condition = core.CfnCondition(
            self,
            "CloudFrontEnableCondition",
            expression=core.Fn.condition_equals(cloudfront_enable_param.value, "true")
        )
        cloudfront_aliases_certificate_rule = core.CfnRule(
            self,
            "CloudFrontAliasesAndCertificateRequiredRule",
            assertions=[
                core.CfnRuleAssertion(
                    assert_=core.Fn.condition_not(
                        core.Fn.condition_equals(cloudfront_certificate_arn_param.value_as_string, "")
                    ),
                    assert_description="When providing a set of aliases for CloudFront, you must also supply a trusted CloudFrontCertificateArn parameter which validates your authorization to use those domain names"
                )
            ],
            rule_condition=core.Fn.condition_not(
                core.Fn.condition_each_member_equals(cloudfront_aliases_param.value_as_list, "")
            )
        )
        cloudfront_price_class_param = core.CfnParameter(
            self,
            "CloudFrontPriceClass",
            # possible to use a map to make the values more human readable
            allowed_values = [
                "PriceClass_All",
                "PriceClass_200",
                "PriceClass_100"
            ],
            default="PriceClass_All",
            description="Required: Price class to use for CloudFront CDN (only applies when CloudFront enabled)."
        )
        cloudfront_distribution = aws_cloudfront.CfnDistribution(
            self,
            "CloudFrontDistribution",
            distribution_config=aws_cloudfront.CfnDistribution.DistributionConfigProperty(
                aliases=core.Token.as_list(
                    core.Fn.condition_if(
                        cloudfront_aliases_exist_condition.logical_id,
                        cloudfront_aliases_param.value_as_list,
                        core.Aws.NO_VALUE
                    )
                ),
                comment=core.Aws.STACK_NAME,
                default_cache_behavior=aws_cloudfront.CfnDistribution.DefaultCacheBehaviorProperty(
                    allowed_methods=[
                        "DELETE",
                        "GET",
                        "HEAD",
                        "OPTIONS",
                        "PATCH",
                        "POST",
                        "PUT"
                    ],
                    compress=True,
                    default_ttl=86400,
                    forwarded_values=aws_cloudfront.CfnDistribution.ForwardedValuesProperty(
                        cookies=aws_cloudfront.CfnDistribution.CookiesProperty(
                            forward="whitelist",
                            whitelisted_names=[ "SESS*" ]
                        ),
                        headers=[
                            "CloudFront-Forwarded-Proto",
                            "Host",
                            "Origin"
                        ],
                        query_string=True
                    ),
                    min_ttl=0,
                    max_ttl=31536000,
                    target_origin_id="alb",
                    # when alb certificate is supplied, we automatically redirect http traffic to https.
                    # using that as a best-practice pattern, we redirect all traffic at cloudfront as well,
                    # covered either by the default AWS cloudfront cert when no aliases are supplied, or by the
                    # cert of the CloudFrontCertificateArn parameter.
                    viewer_protocol_policy="redirect-to-https"
                ),
                enabled=True,
                origins=[ aws_cloudfront.CfnDistribution.OriginProperty(
                    domain_name=alb.attr_dns_name,
                    id="alb",
                    custom_origin_config=aws_cloudfront.CfnDistribution.CustomOriginConfigProperty(
                        # if there is an ssl cert on the alb, use https only
                        origin_protocol_policy=core.Token.as_string(
                            core.Fn.condition_if(
                                certificate_arn_exists_condition.logical_id,
                                "https-only",
                                "http-only"
                            )
                        ),
                        origin_ssl_protocols=[ "TLSv1.1", "TLSv1.2" ]
                    )
                )],
                price_class=cloudfront_price_class_param.value_as_string,
                viewer_certificate=aws_cloudfront.CfnDistribution.ViewerCertificateProperty(
                    acm_certificate_arn=core.Token.as_string(
                        core.Fn.condition_if(
                            cloudfront_certificate_arn_exists_condition.logical_id,
                            cloudfront_certificate_arn_param.value_as_string,
                            core.Aws.NO_VALUE
                        )
                    ),
                    cloud_front_default_certificate=core.Fn.condition_if(
                        cloudfront_certificate_arn_exists_condition.logical_id,
                        core.Aws.NO_VALUE,
                        True
                    ),
                    minimum_protocol_version=core.Token.as_string(
                        core.Fn.condition_if(
                            cloudfront_certificate_arn_exists_condition.logical_id,
                            "TLSv1.2_2018",
                            core.Aws.NO_VALUE
                        )
                    ),
                    ssl_support_method=core.Token.as_string(
                        core.Fn.condition_if(
                            cloudfront_certificate_arn_exists_condition.logical_id,
                            "sni-only",
                            core.Aws.NO_VALUE
                        )
                    )
                )
            )
        )
        cloudfront_distribution_arn = core.Arn.format(
            components=core.ArnComponents(
                account="",
                region="",
                resource="distribution",
                resource_name=cloudfront_distribution.ref,
                service="cloudfront"
            ),
            stack=self
        )
        cloudfront_distribution.cfn_options.condition = cloudfront_enable_condition
        cloudfront_distribution_endpoint_output = core.CfnOutput(
            self,
            "CloudFrontDistributionEndpointOutput",
            condition=cloudfront_enable_condition,
            description="The distribution DNS name endpoint for connection. Configure in Drupal's settings.php.",
            value=cloudfront_distribution.attr_domain_name
        )

        # app
        app_instance_role = aws_iam.Role(
            self,
            "AppInstanceRole",
            assumed_by=aws_iam.ServicePrincipal("ec2.amazonaws.com"),
            inline_policies={
                "AllowStreamLogsToCloudWatch": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "logs:CreateLogStream",
                                "logs:DescribeLogStreams",
                                "logs:PutLogEvents"
                            ],
                            resources=[
                                access_log_group.attr_arn,
                                error_log_group.attr_arn,
                                system_log_group.attr_arn
                            ]
                        )
                    ]
                ),
                "AllowStreamMetricsToCloudWatch": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "ec2:DescribeVolumes",
                                "ec2:DescribeTags",
                                "cloudwatch:GetMetricStatistics",
                                "cloudwatch:ListMetrics",
                                "cloudwatch:PutMetricData"
                            ],
                            resources=[ "*" ]
                        )
                    ]
                ),
                "AllowGetFromArtifactBucket": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:Get*",
                                "s3:Head*"
                            ],
                            resources=[
                                "arn:{}:s3:::{}/*".format(
                                    core.Aws.PARTITION,
                                    core.Token.as_string(
                                        core.Fn.condition_if(
                                            pipeline_artifact_bucket_name_exists_condition.logical_id,
                                            pipeline_artifact_bucket_name_param.value_as_string,
                                            pipeline_artifact_bucket.ref
                                        )
                                    )
                                )
                            ]
                        )
                    ]
                ),
                "AllowDescribeAutoScaling": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "autoscaling:Describe*"
                            ],
                            resources=[ "*" ]
                        )
                    ]
                )
            },
            managed_policies=[aws_iam.ManagedPolicy.from_aws_managed_policy_name("AmazonSSMManagedInstanceCore")]
        )
        app_instance_role.attach_inline_policy(secret_policy)
        instance_profile = aws_iam.CfnInstanceProfile(
            self,
            "AppInstanceProfile",
            roles=[app_instance_role.role_name]
        )

        # autoscaling
        __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        allowed_instance_types = yaml.load(
            open(os.path.join(__location__, "allowed_instance_types.yaml")),
            Loader=yaml.SafeLoader
        )["allowed_instance_types"]
        app_instance_type_param = core.CfnParameter(
            self,
            "AppLaunchConfigInstanceType",
            allowed_values=allowed_instance_types,
            default="m5.xlarge",
            description="Required: The EC2 instance type for the application Auto Scaling Group."
        )
        asg_desired_capacity_param = core.CfnParameter(
            self,
            "AppAsgDesiredCapacity",
            default=1,
            description="Required: The desired capacity of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        asg_max_size_param = core.CfnParameter(
            self,
            "AppAsgMaxSize",
            default=2,
            description="Required: The maximum size of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        asg_min_size_param = core.CfnParameter(
            self,
            "AppAsgMinSize",
            default=1,
            description="Required: The minimum size of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        with open("drupal/app_launch_config_user_data.sh") as f:
            app_launch_config_user_data = f.read()
        launch_config = aws_autoscaling.CfnLaunchConfiguration(
            self,
            "AppLaunchConfig",
            image_id=core.Fn.find_in_map("AWSAMIRegionMap", core.Aws.REGION, "OEDRUPAL"),
            instance_type=app_instance_type_param.value_as_string,
            iam_instance_profile=instance_profile.ref,
            security_groups=[app_sg.ref],
            user_data=(
                core.Fn.base64(
                    core.Fn.sub(
                        app_launch_config_user_data,
                        {
                            "CloudFrontHost": core.Token.as_string(
                                core.Fn.condition_if(
                                    cloudfront_enable_condition.logical_id,
                                    core.Fn.condition_if(
                                        cloudfront_aliases_exist_condition.logical_id,
                                        core.Fn.select(0, cloudfront_aliases_param.value_as_list),
                                        cloudfront_distribution.attr_domain_name
                                    ),
                                    ""
                                )
                            ),
                            "DrupalSalt": core.Fn.base64(core.Aws.STACK_ID),
                            "ElastiCacheClusterHost": core.Token.as_string(
                                core.Fn.condition_if(
                                    elasticache_enable_condition.logical_id,
                                    elasticache_cluster.attr_configuration_endpoint_address,
                                    ""
                                )
                            ),
                            "ElastiCacheClusterPort": core.Token.as_string(
                                core.Fn.condition_if(
                                    elasticache_enable_condition.logical_id,
                                    elasticache_cluster.attr_configuration_endpoint_port,
                                    ""
                                )
                            ),
                            "SecretArn": core.Token.as_string(
                                core.Fn.condition_if(
                                    secret_arn_exists_condition.logical_id,
                                    secret_arn_param.value_as_string,
                                    secret.ref
                                )
                            )
                        }
                    )
                )
            )
        )
        asg = aws_autoscaling.CfnAutoScalingGroup(
            self,
            "AppAsg",
            launch_configuration_name=launch_config.ref,
            desired_capacity=core.Token.as_string(asg_desired_capacity_param.value),
            max_size=core.Token.as_string(asg_max_size_param.value),
            min_size=core.Token.as_string(asg_min_size_param.value),
            target_group_arns=[
                core.Token.as_string(
                    core.Fn.condition_if(
                        certificate_arn_exists_condition.logical_id,
                        https_target_group.ref,
                        http_target_group.ref
                    )
                )
            ],
            vpc_zone_identifier=core.Token.as_list(
                core.Fn.condition_if(
                    vpc_given_condition.logical_id,
                    [
                        vpc_private_subnet_id1_param.value_as_string,
                        vpc_private_subnet_id2_param.value_as_string
                    ],
                    [
                        vpc_private_subnet1.ref,
                        vpc_private_subnet2.ref
                    ]
                )
            )
        )
        asg.cfn_options.creation_policy=core.CfnCreationPolicy(
            resource_signal=core.CfnResourceSignal(
                count=1,
                timeout="PT15M"
            )
        )
        asg.cfn_options.update_policy=core.CfnUpdatePolicy(
            auto_scaling_rolling_update=core.CfnAutoScalingRollingUpdate(
                min_instances_in_service=1,
                pause_time="PT15M",
                wait_on_resource_signals=True
            ),
            auto_scaling_scheduled_action=core.CfnAutoScalingScheduledAction(
                ignore_unmodified_group_size_properties=True
            )
        )
        core.Tag.add(asg, "Name", "{}/AppAsg".format(core.Aws.STACK_NAME))
        asg.add_depends_on(db_instance)
        asg_web_server_scale_up_policy = aws_autoscaling.CfnScalingPolicy(
            self,
            "WebServerScaleUpPolicy",
            adjustment_type="ChangeInCapacity",
            auto_scaling_group_name=asg.ref,
            cooldown="60",
            scaling_adjustment=1
        )
        asg_web_server_scale_down_policy = aws_autoscaling.CfnScalingPolicy(
            self,
            "WebServerScaleDownPolicy",
            adjustment_type="ChangeInCapacity",
            auto_scaling_group_name=asg.ref,
            cooldown="60",
            scaling_adjustment=-1
        )

        # cloudwatch alarms
        cpu_alarm_high = aws_cloudwatch.CfnAlarm(
            self,
            "CPUAlarmHigh",
            comparison_operator="GreaterThanThreshold",
            evaluation_periods=2,
            actions_enabled=None,
            alarm_actions=[ asg_web_server_scale_up_policy.ref, notification_topic.topic_arn ],
            alarm_description="Scale-up if CPU > 90% for 10mins",
            dimensions=[ aws_cloudwatch.CfnAlarm.DimensionProperty(
                name="AutoScalingGroupName",
                value=asg.ref
            )],
            metric_name="CPUUtilization",
            namespace="AWS/EC2",
            period=300,
            statistic="Average",
            threshold=90
        )
        cpu_alarm_low = aws_cloudwatch.CfnAlarm(
            self,
            "CPUAlarmLow",
            comparison_operator="LessThanThreshold",
            evaluation_periods=2,
            actions_enabled=None,
            alarm_actions=[ asg_web_server_scale_down_policy.ref, notification_topic.topic_arn ],
            alarm_description="Scale-down if CPU < 70% for 10mins",
            dimensions=[ aws_cloudwatch.CfnAlarm.DimensionProperty(
                name="AutoScalingGroupName",
                value=asg.ref
            )],
            metric_name="CPUUtilization",
            namespace="AWS/EC2",
            period=300,
            statistic="Average",
            threshold=70
        )

        sg_http_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AppSgHttpIngress",
            from_port=80,
            group_id=app_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=alb_sg.ref,
            to_port=80
        )
        sg_http_ingress.cfn_options.condition = certificate_arn_does_not_exist_condition

        sg_https_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AppSgHttpsIngress",
            from_port=443,
            group_id=app_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=alb_sg.ref,
            to_port=443
        )
        sg_https_ingress.cfn_options.condition = certificate_arn_exists_condition

        # codebuild
        codebuild_transform_service_role = aws_iam.Role(
            self,
            "CodeBuildTransformServiceRole",
            assumed_by=aws_iam.ServicePrincipal("codebuild.amazonaws.com"),
            inline_policies={
                "TransformRolePermssions": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "logs:CreateLogGroup",
                                "logs:CreateLogStream",
                                "logs:PutLogEvents"
                            ],
                            resources=[ "*" ]
                        ),
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:GetObject",
                                "s3:PutObject"
                            ],
                            resources=[
                                core.Arn.format(
                                    components=core.ArnComponents(
                                        account="",
                                        region="",
                                        resource=core.Token.as_string(
                                            core.Fn.condition_if(
                                                pipeline_artifact_bucket_name_exists_condition.logical_id,
                                                pipeline_artifact_bucket_name_param.value_as_string,
                                                pipeline_artifact_bucket.ref
                                            )
                                        ),
                                        resource_name="*",
                                        service="s3"
                                    ),
                                    stack=self
                                )
                            ]
                        )
                    ]
                )
            }
        )
        with open("drupal/codebuild_transform_project_buildspec.yml") as f:
            codebuild_transform_project_buildspec = f.read()
        codebuild_transform_project = aws_codebuild.CfnProject(
            self,
            "CodeBuildTransformProject",
            artifacts=aws_codebuild.CfnProject.ArtifactsProperty(
                type="CODEPIPELINE",
            ),
            environment=aws_codebuild.CfnProject.EnvironmentProperty(
                compute_type="BUILD_GENERAL1_SMALL",
                environment_variables=[
                    aws_codebuild.CfnProject.EnvironmentVariableProperty(
                        name="AUTO_SCALING_GROUP_NAME",
                        value=asg.ref,
                    )
                ],
                image="aws/codebuild/standard:4.0",
                type="LINUX_CONTAINER"
            ),
            name="{}-transform".format(core.Aws.STACK_NAME),
            service_role=codebuild_transform_service_role.role_arn,
            source=aws_codebuild.CfnProject.SourceProperty(
                build_spec=codebuild_transform_project_buildspec,
                type="CODEPIPELINE"
            )
        )

        # cicd pipeline
        # TODO: Tighten role / use managed roles?
        pipeline_role = aws_iam.Role(
            self,
            "PipelineRole",
            assumed_by=aws_iam.ServicePrincipal("codepipeline.amazonaws.com"),
            inline_policies={
                "CodePipelinePerms": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "codebuild:BatchGetBuilds",
                                "codebuild:StartBuild",
                                "codedeploy:GetApplication",
                                "codedeploy:GetDeploymentGroup",
                                "codedeploy:ListApplications",
                                "codedeploy:ListDeploymentGroups",
                                "codepipeline:*",
                                "iam:ListRoles",
                                "iam:PassRole",
                                "lambda:GetFunctionConfiguration",
                                "lambda:ListFunctions",
                                "s3:CreateBucket",
                                "s3:GetBucketPolicy",
                                "s3:GetObject",
                                "s3:ListAllMyBuckets",
                                "s3:ListBucket",
                                "s3:PutBucketPolicy"
                            ],
                            resources=[ "*" ]
                        )
                    ]
                )
            }
        )

        source_stage_role = aws_iam.Role(
            self,
            "SourceStageRole",
            assumed_by=aws_iam.ArnPrincipal(pipeline_role.role_arn),
            inline_policies={
                "SourceRolePerms": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:Get*",
                                "s3:Head*"
                            ],
                            resources=[
                                "arn:{}:s3:::{}/{}".format(
                                    core.Aws.PARTITION,
                                    source_artifact_s3_bucket_param.value_as_string,
                                    source_artifact_s3_object_key_param.value_as_string
                                )
                            ]
                        ),
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:GetBucketVersioning"
                            ],
                            resources=[
                                "arn:{}:s3:::{}".format(
                                    core.Aws.PARTITION,
                                    source_artifact_s3_bucket_param.value_as_string
                                )
                            ]
                        ),
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:*"
                            ],
                            resources=[
                                "arn:{}:s3:::{}/*".format(
                                    core.Aws.PARTITION,
                                    core.Token.as_string(
                                        core.Fn.condition_if(
                                            pipeline_artifact_bucket_name_exists_condition.logical_id,
                                            pipeline_artifact_bucket_name_param.value_as_string,
                                            pipeline_artifact_bucket.ref
                                        )
                                    )
                                )
                            ]
                        )
                    ]
                )
            }
        )

        codedeploy_transform_stage_role = aws_iam.Role(
            self,
            "TransformStageRole",
            assumed_by=aws_iam.ArnPrincipal(pipeline_role.role_arn),
            inline_policies={}
        )

        deploy_stage_role = aws_iam.Role(
            self,
            "DeployStageRole",
            assumed_by=aws_iam.ArnPrincipal(pipeline_role.role_arn),
            inline_policies={
                "DeployRolePerms": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "codedeploy:*"
                            ],
                            resources=[ "*" ]
                        ),
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:Get*",
                                "s3:Head*",
                                "s3:PutObject"
                            ],
                            resources=[
                                "arn:{}:s3:::{}/*".format(
                                    core.Aws.PARTITION,
                                    core.Token.as_string(
                                        core.Fn.condition_if(
                                            pipeline_artifact_bucket_name_exists_condition.logical_id,
                                            pipeline_artifact_bucket_name_param.value_as_string,
                                            pipeline_artifact_bucket.ref
                                        )
                                    )
                                )
                            ]
                        )
                    ]
                )
            }
        )

        code_deploy_application = aws_codedeploy.CfnApplication(
            self,
            "CodeDeployApplication",
            application_name=core.Aws.STACK_NAME,
            compute_platform="Server"
        )
        code_deploy_role = aws_iam.Role(
             self,
            "CodeDeployRole",
            assumed_by=aws_iam.ServicePrincipal("codedeploy.{}.amazonaws.com".format(core.Aws.REGION)),
            inline_policies={
                "DeployRolePermssions": aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:GetObject",
                                "s3:PutObject"
                            ],
                            resources=[
                                "arn:{}:s3:::{}/*".format(
                                    core.Aws.PARTITION,
                                    core.Token.as_string(
                                        core.Fn.condition_if(
                                            pipeline_artifact_bucket_name_exists_condition.logical_id,
                                            pipeline_artifact_bucket_name_param.value_as_string,
                                            pipeline_artifact_bucket.ref
                                        )
                                    )
                                )
                            ]
                        ),
                    ]
                )
            },
            managed_policies=[aws_iam.ManagedPolicy.from_aws_managed_policy_name("service-role/AWSCodeDeployRole")]
        )
        code_deploy_deployment_group = aws_codedeploy.CfnDeploymentGroup(
            self,
            "CodeDeployDeploymentGroup",
            application_name=code_deploy_application.application_name,
            auto_scaling_groups=[asg.ref],
            deployment_group_name="{}-app".format(core.Aws.STACK_NAME),
            deployment_config_name=aws_codedeploy.ServerDeploymentConfig.ALL_AT_ONCE.deployment_config_name,
            service_role_arn=code_deploy_role.role_arn,
            trigger_configurations=[
                aws_codedeploy.CfnDeploymentGroup.TriggerConfigProperty(
                    trigger_events=[
                        "DeploymentSuccess",
                        "DeploymentRollback"
                    ],
                    trigger_name="DeploymentNotification",
                    trigger_target_arn=notification_topic.topic_arn
                )
            ]
        )
        pipeline = aws_codepipeline.CfnPipeline(
            self,
            "Pipeline",
            artifact_store=aws_codepipeline.CfnPipeline.ArtifactStoreProperty(
                location=core.Token.as_string(
                    core.Fn.condition_if(
                        pipeline_artifact_bucket_name_exists_condition.logical_id,
                        pipeline_artifact_bucket_name_param.value_as_string,
                        pipeline_artifact_bucket.ref
                    )
                ),
                type="S3"
            ),
            role_arn=pipeline_role.role_arn,
            stages=[
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Source",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Source",
                                owner="AWS",
                                provider="S3",
                                version="1"
                            ),
                            configuration={
                                "S3Bucket": source_artifact_s3_bucket_param.value_as_string,
                                "S3ObjectKey": source_artifact_s3_object_key_param.value_as_string
                            },
                            output_artifacts=[
                                aws_codepipeline.CfnPipeline.OutputArtifactProperty(
                                    name="build"
                                )
                            ],
                            name="SourceAction",
                            role_arn=source_stage_role.role_arn
                        )
                    ]
                ),
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Transform",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Build",
                                owner="AWS",
                                provider="CodeBuild",
                                version="1"
                            ),
                            configuration={
                                "ProjectName": codebuild_transform_project.ref
                            },
                            input_artifacts=[
                                aws_codepipeline.CfnPipeline.InputArtifactProperty(
                                    name="build",
                                )
                            ],
                            name="TransformAction",
                            output_artifacts=[
                                aws_codepipeline.CfnPipeline.OutputArtifactProperty(
                                    name="transformed"
                                )
                            ]
                        )
                    ]
                ),
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Deploy",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Deploy",
                                owner="AWS",
                                provider="CodeDeploy",
                                version="1"
                            ),
                            configuration={
                                "ApplicationName": code_deploy_application.ref,
                                "DeploymentGroupName": code_deploy_deployment_group.ref,
                            },
                            input_artifacts=[
                                aws_codepipeline.CfnPipeline.InputArtifactProperty(
                                    name="transformed"
                                )
                            ],
                            name="DeployAction",
                            role_arn=deploy_stage_role.role_arn
                        )
                    ]
                )
            ]
        )

        # AWS::CloudFormation::Interface
        self.template_options.metadata = {
            "AWS::CloudFormation::Interface": {
                "ParameterGroups": [
                    {
                        "Label": {
                            "default": "CI/CD"
                        },
                        "Parameters": [
                            notification_email_param.logical_id,
                            source_artifact_s3_bucket_param.logical_id,
                            source_artifact_s3_object_key_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "Data Snapshots"
                        },
                        "Parameters": [
                            db_snapshot_identifier_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "Application Config"
                        },
                        "Parameters": [
                            certificate_arn_param.logical_id,
                            secret_arn_param.logical_id,
                            app_instance_type_param.logical_id,
                            asg_min_size_param.logical_id,
                            asg_max_size_param.logical_id,
                            asg_desired_capacity_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "ElastiCache memcached"
                        },
                        "Parameters": [
                            elasticache_enable_param.logical_id,
                            elasticache_cluster_engine_version_param.logical_id,
                            elasticache_cluster_cache_node_type_param.logical_id,
                            elasticache_cluster_num_cache_nodes_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "CloudFront"
                        },
                        "Parameters": [
                            cloudfront_enable_param.logical_id,
                            cloudfront_certificate_arn_param.logical_id,
                            cloudfront_aliases_param.logical_id,
                            cloudfront_price_class_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "VPC"
                        },
                        "Parameters": [
                            vpc_id_param.logical_id,
                            vpc_private_subnet_id1_param.logical_id,
                            vpc_private_subnet_id2_param.logical_id,
                            vpc_public_subnet_id1_param.logical_id,
                            vpc_public_subnet_id2_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "Template Development"
                        },
                        "Parameters": [
                            pipeline_artifact_bucket_name_param.logical_id
                        ]
                    }
                ],
                "ParameterLabels": {
                    app_instance_type_param.logical_id: {
                        "default": "Instance Type"
                    },
                    asg_desired_capacity_param.logical_id: {
                        "default": "Auto Scaling Group Desired Capacity"
                    },
                    asg_max_size_param.logical_id: {
                        "default": "Auto Scaling Group Maximum Size"
                    },
                    asg_min_size_param.logical_id: {
                        "default": "Auto Scaling Group Minimum Size"
                    },
                    certificate_arn_param.logical_id: {
                        "default": "ACM Certificate ARN"
                    },
                    cloudfront_aliases_param.logical_id: {
                        "default": "CloudFront Aliases"
                    },
                    cloudfront_certificate_arn_param.logical_id: {
                        "default": "CloudFront ACM Certificate ARN"
                    },
                    cloudfront_enable_param.logical_id: {
                        "default": "Enable CloudFront"
                    },
                    cloudfront_price_class_param.logical_id: {
                        "default": "CloudFront Price Class"
                    },
                    db_snapshot_identifier_param.logical_id: {
                        "default": "RDS Snapshot Identifier"
                    },
                    elasticache_cluster_cache_node_type_param.logical_id: {
                        "default": "ElastiCache Cache Node Type"
                    },
                    elasticache_cluster_engine_version_param.logical_id: {
                        "default": "ElastiCache Engine Version"
                    },
                    elasticache_cluster_num_cache_nodes_param.logical_id: {
                        "default": "ElastiCache Num Nodes"
                    },
                    elasticache_enable_param.logical_id: {
                        "default": "Enable ElastiCache"
                    },
                    notification_email_param.logical_id: {
                        "default": "Notification Email"
                    },
                    pipeline_artifact_bucket_name_param.logical_id: {
                        "default": "CodePipeline Bucket Name"
                    },
                    secret_arn_param.logical_id: {
                        "default": "SecretsManager secret ARN"
                    },
                    source_artifact_s3_bucket_param.logical_id: {
                        "default": "Source Artifact S3 Bucket Name"
                    },
                    source_artifact_s3_object_key_param.logical_id: {
                        "default": "Source Artifact S3 Object Key (path)"
                    },
                    vpc_id_param.logical_id: {
                        "default": "VPC ID"
                    },
                    vpc_private_subnet_id1_param.logical_id: {
                        "default": "Private Subnet ID 1"
                    },
                    vpc_private_subnet_id2_param.logical_id: {
                        "default": "Private Subnet ID 2"
                    },
                    vpc_public_subnet_id1_param.logical_id: {
                        "default": "Public Subnet ID 1"
                    },
                    vpc_public_subnet_id2_param.logical_id: {
                        "default": "Public Subnet ID 2"
                    }
                }
            }
        }
